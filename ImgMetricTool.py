ICON_DATA = """
iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAC0FBMVEUAAABZZG+Hj5U2RlU8S1lJVWExQlE5SFY7S1lCT11NWmVtdn4xQlFCUF1KV2RSXWdmcHotPk0vQFAwQVEyQ1IyQlI0RFM2RlQtP09CUV5MWWRJVmI5SFRUXmlcZm9ha3RweYE0RVU2RlQ3RlU6Slk1RVNEUV0zQ1E5R1ZEUl8/TVpEUV1PW2ZSXmgyRFUuPk08SVc6SVg/TVxOWGM+TFoqPU3///8sPk0qPk4rPk8pPEwsP1ACj9l4rOIkTGj+//7e8PvW5fXN3/LJ3PErPEvX5/XV5PRNWmYnRV3T5PPH3fHp6erU19oFi9VTYGwrP1DS4fPM3/HD2vDE2fDA1u9Fp+TZ2tyXm6AXa579/v3x+f3Z5vXF3PHG2/APd7QsPUzJ3fLB2fC91e6uzeuqyusJhMaVmZ7V5vTS4/PO4fPL3/PJ3fHD2/HC1+6xz+za3N0CjdwpPEonOUn3+vzU4vTQ4fPQ4vLK3fHv8PC20e7s7O0vQVL7/Pzx9vvv9frT5PTN4fK/2PC91/C91e+71O+80+1qu+ppueqJtubMzs+ZnqIgTW1NWWT5+vrl8Pfe6fba6Pb09fXc6fXL3fLw8vHL3PG60u240eyry+ukyeuTvegDkN4Cj9vS1NXLzM65vL2MkZZ/hovy+Pz29/ff7PfY5fXP3/LE2fLI2vG30/Ds7ezo6eqzzeqItufl5ubi5eXd3+ACj9zV2NrCxMYJg8a9wMKhpamdoqZvdn40RFPo9Pv3+PXi7fXY6PW0z+uny+ugwupGqOXX2doHi9eTs9PP0dLFx8kKhceztrmvsrSrr7GXoKoXbKCEiY97gYh1fIRyeYFkbXZdZW5KVmJHUl0/TVrD4PSl0PHN3e6bx+touOpKqOaQueGvxeB0qd5ImtwLh8sKhMWSqsF+nLqbnqOPlpuSlpmRlZmGi5FTa4Jnb3ggT3AgTW5YY2xPXWo4SFa8vdhwAAAANXRSTlMAGQbDmjvPvKtoNBLlhFgrCvv48u/s4dLMlk5IOiYgFQ7s6tuwr6efjIt5b2VB+fS0kX15dq+p8q8AAAS6SURBVEjHtdVld9NQHAbwMB/u7u5+15sES9IEWqQKo7SlCvVBmbsDG8N9Ptzd3d3d3fUrkCBLSweMc+B3TvPqeXr/ucnJRf6RalUDewTW8qtcuFVo+7YYBADCxEYBTf8YrxpSB0hQgLEFHNUJJG1rVPtdvEoIlKBYXu7OoklbxhSfLUvEIVq/26/zNetjWOLuSTOTk1NmGY9suJMy99QeHAL/lkjFakAMe50QlnzQHrtakT9gQGHBQEVkzjUUbxNYYT4AotdPqsRZqw0Zh8xL8gsLtxYUFD52Ld+Fgro9EF9dMPAuIXnp0rUGpzP+8NL46ZyNGzeuTdoOJfWq+s6Pwqtxs6Jc6WJSxJCZRlUYZzBLpcrBYcNqP+9PPZiXMMsWpXWSaWlEjDydLXDYPNspAWgI4i0Ew4pSiDSZ3Cm1ytJIjWZn+FcTObkLSiWwmffzkqCvVPOImIXZ6aukMplWoQjH3Bj4DtsddxMEeRU6wMQEo2K+Rmk2K+VyebbZnDvM05azwGuJKnVA7rIMsV6vMC1RajR2pcn0bCzvwoXn6/bi7RFeKAqORTNqhmC0DilNiGLs4gcjPRw/fuAFXre250R5SVT07DkMI9MSakYkJcm7o3lHj97PKEKBx6tbHUwMk9nmzFYzVCyjpg9G6cl9Q7zsW4DhNcrzrQFWEqnUS23R87My9TabNTZ9UZg3VdJHPITfVIDlrIjI1lMG5RKT0mCUZ5qWmAd6eTTrjaRxeaE5AMfmHFotmx+riIjQisUa19qI/AHe5k2EQXxBAMascNrmWIhUgzOGtlhkGvuJpxMm7NgxgbNjwunTT9ThoBFfgO6iA45UmhZJ5QaryGIhxfLzg7xtLoX8SC2F7lMpMquaIBjKIaJFdJTWES50u4Xf6XRCd9wl3B8pVwc7F5nlWiUlqcXxVKyYVBgXx61fP9zD+pk38QC+EIReGrzBKI0Wsze9Rq8RG+PjB/+0rZuFeChf6IwKFiipKNKxcHEWZSNla7IzN43Ytm1EuW1zS4CgFl9oBrDtySvnEeqV5PyVanqedNXC3UM9XZ25R9AQ4flVB1dUMhFNM1qxlLaIoqjYXaM8fCrZgnNvBq8rip4UWdREtFxupVPVdod90yTOmO/2l+E9q3gWWjcA1+ZG610uU4RCIzdkx2+IHPfNsmXsJSwHQ5sgXkKFYFek2KhceliZnmHIMptvT506bSr7Y927FZcnadAK8RaMwu2RBLVo0ULSkUZlLsqfPHnr1smcgiNzL0sSa/p8h6tjWHHSbKVTlGpl7FrtifE/PFx+EZYPxGvRAAB4Jmk2JU0VMTGKNedncD68fzti3WUJGuzns0BDwHJfTFgRYyUIinKFT+HcOLO8+AbEg2v/nG/dSCcQAAzAz+fiUuiMxSZT7pQp18Nz9o8pk6AwwOf//YIFnO4BOAB7JxavY7+OCZsWzNy8cw+AeJuaiI+OOi7PHjWB/rgEYDCvrPRl6ZW9bBqv26eCM6vJ13wXhBPYqR5EuTORvULQrm8VxFc/Aadj+XyBXTv5BwU1Dg4IbYFUpLuQW6C3H1JJTRMFLP/alT70e7FxXbtWSGXVErCqt0Qqzx/X1a+F/IXa/Tu3QP6fL2nq4sYE5TgOAAAAAElFTkSuQmCC
"""

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox
import subprocess
import os
import re
import threading
import statistics
import csv
import math
import random
import ctypes
import tempfile
import uuid
from matplotlib import patheffects
from matplotlib.offsetbox import VPacker, TextArea, AnnotationBbox
from concurrent.futures import ThreadPoolExecutor

# --- OPTIONAL DEPENDENCIES ---
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    DND_SUPPORT = True
except ImportError:
    DND_SUPPORT = False

try:
    import matplotlib.pyplot as plt
    import matplotlib.colors as mcolors
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
    from matplotlib.figure import Figure 
    from mpl_toolkits.axes_grid1.inset_locator import inset_axes
    from matplotlib.widgets import CheckButtons 
    import numpy as np
    from PIL import Image, ImageChops, ImageFilter, ImageOps
    
    try:
        import pillow_avif
    except ImportError:
        pass

    MPL_SUPPORT = True
    PIL_SUPPORT = True
except ImportError:
    MPL_SUPPORT = False
    PIL_SUPPORT = False

try:
    from skimage import color, metrics, util
    SKIMAGE_SUPPORT = True
except ImportError:
    SKIMAGE_SUPPORT = False

try:
    import cv2
    CV_SUPPORT = True
except ImportError:
    CV_SUPPORT = False

try:
    from scipy.stats import gaussian_kde
    SCIPY_SUPPORT = True
except ImportError:
    SCIPY_SUPPORT = False
   
# --- CONFIGURATION ---
BIN_DIR = os.path.dirname(os.path.abspath(__file__))
SSIM_EXE = os.path.join(BIN_DIR, "ssimulacra2.exe")
BUTTER_EXE = os.path.join(BIN_DIR, "butteraugli_main.exe")
DJXL_EXE = os.path.join(BIN_DIR, "djxl.exe") 
INTENSITY = "80"

# Formats
ALL_SUPPORTED_EXTS = ('.png', '.jpg', '.jpeg', '.jxl', '.webp', '.avif', '.bmp', '.tiff', '.tif')
CLI_NATIVE_EXTS = ('.png', '.jpg', '.jpeg', '.jxl')

# Fallback for Window class if dnd is missing
BaseClass = TkinterDnD.Tk if DND_SUPPORT else tk.Tk

def apply_dark_theme(window):

    window.withdraw()
    window.update()
    
    try:
        hwnd = ctypes.windll.user32.GetParent(window.winfo_id())
        
        # DARK MODE 
        ctypes.windll.dwmapi.DwmSetWindowAttribute(
            hwnd, 20, ctypes.byref(ctypes.c_int(1)), 4
        )

        ex_style = ctypes.windll.user32.GetWindowLongW(hwnd, -20)
        new_ex_style = (ex_style | 0x00040000) & ~0x00000080
        ctypes.windll.user32.SetWindowLongW(hwnd, -20, new_ex_style)

        ctypes.windll.user32.SetWindowPos(hwnd, 0, 0, 0, 0, 0, 0x0020 | 0x0002 | 0x0001 | 0x0004)
        
    except Exception as e:
        print(f"Theme Error: {e}")
    
    window.deiconify()

# =============================================================================
#  UNIVERSAL FORMAT BRIDGE
# =============================================================================
def get_ready_image(file_path):
    if not os.path.exists(file_path):
        return None, False, "File not found."

    ext = os.path.splitext(file_path)[1].lower()
    
    # 1. Native Check: O(1) Lookup.
    if ext in CLI_NATIVE_EXTS:
        return file_path, False, "Native"
    
    # 2. If not native, check Pillow support
    if not PIL_SUPPORT:
        return None, False, "File not found or supported. Pillow must be installed to continue."
    
    try:
        # 3. Convert non-native formats to PNG for the tools
        with Image.open(file_path) as img:
            rgb_img = img.convert("RGB")
            base_name = os.path.basename(file_path)
            temp_path = os.path.join(tempfile.gettempdir(), f"{base_name}_{random.randint(1000,9999)}.tmp_bridge.png")
            rgb_img.save(temp_path, format="PNG", compress_level=0)
            return temp_path, True, "Converted"
    except Exception as e:
        return None, False, f"Conversion Failed: {str(e)}"

def cleanup_image(path, is_temp):
    if is_temp and os.path.exists(path):
        try: os.remove(path)
        except: pass

# =============================================================================
#  CLASS: OPTIMIZER (RD-CURVE)
# =============================================================================
class OptimizerWindow(tk.Toplevel):
    def __init__(self, parent, ssim_exe):
        super().__init__(parent)
        self.title("Codec Optimizer (RD-Curve)")
        self.geometry("800x700")
        self.ssim_exe = ssim_exe
        apply_dark_theme(self)
        
        main_frame = ttk.Frame(self, padding=10)
        main_frame.pack(fill="both", expand=True)

        ttk.Label(main_frame, text="1. Select Original Image:").pack(anchor="w")
        self.ent_orig = ttk.Entry(main_frame)
        self.ent_orig.pack(fill="x", pady=(0, 5))
        if DND_SUPPORT:
            self.ent_orig.drop_target_register(DND_FILES)
            self.ent_orig.dnd_bind('<<Drop>>', lambda e: self.drop_handler(e, self.ent_orig))
            
        ttk.Button(main_frame, text="Browse Original", command=self.set_orig).pack(anchor="e")

        ttk.Label(main_frame, text="2. Add Encoded Versions:").pack(anchor="w", pady=(10, 0))
        self.list_box = tk.Listbox(main_frame, height=8)
        self.list_box.config(bg="#3e3e42", fg="#e1e1e1", borderwidth=0, highlightthickness=0)
        self.list_box.pack(fill="x", pady=5)
        
        if DND_SUPPORT:
            self.list_box.drop_target_register(DND_FILES)
            self.list_box.dnd_bind('<<Drop>>', self.drop_list_handler)
        
        btn_box = ttk.Frame(main_frame)
        btn_box.pack(fill="x")
        ttk.Button(btn_box, text="Add Files", command=self.add_enc).pack(side="left")
        ttk.Button(btn_box, text="Clear List", command=self.clear_enc).pack(side="right")

        ttk.Separator(main_frame, orient="horizontal").pack(fill="x", pady=15)
        
        self.btn_run = ttk.Button(main_frame, text="GENERATE RD-CURVE PLOT", command=self.run_analysis)
        self.btn_run.pack(fill="x", pady=10)
        
        log_container = ttk.Frame(main_frame)
        log_container.pack(fill="both", expand=True)

        self.log = tk.Text(log_container, height=10, font=("Consolas", 9),
                           bg="#1e1e1e", fg="#cccccc", borderwidth=0, padx=10, pady=10)
        
        sb = ttk.Scrollbar(log_container, orient="vertical", command=self.log.yview)
        self.log.configure(yscrollcommand=sb.set)

        sb.pack(side="right", fill="y")
        self.log.pack(side="left", fill="both", expand=True)

    def drop_handler(self, event, widget):
        path = event.data
        if path.startswith('{') and path.endswith('}'): path = path[1:-1]
        widget.delete(0, tk.END); widget.insert(0, path)

    def drop_list_handler(self, event):
        raw = event.data
        files = re.findall(r'\{.*?\}|\S+', raw)
        for f in files:
            clean = f.strip('{}')
            if os.path.exists(clean): self.list_box.insert(tk.END, clean)

    def set_orig(self):
        f = filedialog.askopenfilename(filetypes=[("Images", ALL_SUPPORTED_EXTS)])
        if f: self.ent_orig.delete(0, tk.END); self.ent_orig.insert(0, f)

    def add_enc(self):
        files = filedialog.askopenfilenames(filetypes=[("Images", ALL_SUPPORTED_EXTS)])
        if files:
            for f in files: self.list_box.insert(tk.END, f)

    def clear_enc(self):
        self.list_box.delete(0, tk.END)

    def get_bpp(self, filepath, width, height):
        if width == 0 or height == 0: return 0
        size_bytes = os.path.getsize(filepath)
        size_bits = size_bytes * 8
        return size_bits / (width * height)

    def run_analysis(self):
        orig = self.ent_orig.get().strip().strip('"')
        encoded_files = self.list_box.get(0, tk.END)

        if not orig or not encoded_files:
            messagebox.showerror("Error", "Need Original and at least one Encoded file.")
            return
        
        self.btn_run.config(state="disabled")
        self.log.delete(1.0, tk.END)
        self.log.insert(tk.END, "Starting analysis...\n")
        
        threading.Thread(target=self._process, args=(orig, encoded_files)).start()

    def _process(self, orig, enc_list):
        data_points = []
        w, h = 0, 0
        
        # 1. Prepare Original
        orig_ready, orig_temp, orig_status = get_ready_image(orig)
        
        if orig_ready is None:
            self.log_safe(f"Original Error: {orig_status}\n")
            self.after(0, lambda: self.btn_run.config(state="normal"))
            return
        elif orig_temp:
            self.log_safe(f"Original: {os.path.basename(orig)} -> Converting via Pillow...\n")
        else:
            self.log_safe(f"Original: {os.path.basename(orig)} -> Using Native Decoder\n")

        try:
            # Get Dimensions
            try:
                with Image.open(orig_ready) as img: w, h = img.size
            except:
                if orig.lower().endswith('.jxl') and os.path.exists(DJXL_EXE):
                     subprocess.run([DJXL_EXE, orig, orig+".tmp_size.png"], capture_output=True)
                     if os.path.exists(orig+".tmp_size.png"):
                         with Image.open(orig+".tmp_size.png") as img: w, h = img.size
                         os.remove(orig+".tmp_size.png")
            
            # 2. Process List
            for enc in enc_list:
                enc_ready, enc_temp, enc_status = get_ready_image(enc)
                enc_name = os.path.basename(enc)

                if enc_ready is None:
                    self.log_safe(f"Skipping {enc_name}: {enc_status}\n")
                    continue
                elif enc_temp:
                    self.log_safe(f"Decoding {enc_name}: Converting via Pillow...\n")
                else:
                    self.log_safe(f"Decoding {enc_name}: Native\n")

                res = subprocess.run([self.ssim_exe, orig_ready, enc_ready], capture_output=True, text=True)
                out_text = res.stdout + res.stderr
                floats = [float(x) for x in re.findall(r"[-+]?(?:\d*\.\d+|\d+)", out_text)]
                
                score = -1.0
                if floats:
                    candidates = [x for x in floats if 0 <= x <= 110]
                    if candidates: score = candidates[-1]
                    else: score = floats[-1]
                
                cleanup_image(enc_ready, enc_temp)

                if score != -1.0:
                    bpp = self.get_bpp(enc, w, h)
                    data_points.append({'name': enc_name, 'bpp': bpp, 'score': score})
                    self.log_safe(f"Result: {enc_name} | BPP: {bpp:.3f} | Score: {score:.4f}\n")

            data_points.sort(key=lambda x: x['bpp'])
            self.after(0, lambda: self.show_results(data_points))

        except Exception as e:
            self.log_safe(f"Critical Error: {str(e)}\n")
            self.after(0, lambda: self.btn_run.config(state="normal"))
        finally:
            cleanup_image(orig_ready, orig_temp)

    def log_safe(self, text):
        self.after(0, lambda: self.log.insert(tk.END, text))

    def format_name(self, filename):
        base, ext = os.path.splitext(filename)
        if len(base) > 8:
            return f"{base[:3]}...{base[-3:]}{ext}"
        return filename

    def show_results(self, data):
        self.btn_run.config(state="normal")
        if not data or not MPL_SUPPORT: return

        # 1. Group Data by Extension
        groups = {}
        for d in data:
            ext = os.path.splitext(d['name'])[1].lower()
            if ext not in groups: groups[ext] = []
            groups[ext].append(d)

        # 2. Window Setup
        plot_win = tk.Toplevel(self)
        plot_win.title("Rate-Distortion Analysis")
        plot_win.geometry("1200x800")
        plot_win.configure(bg="#2d2d30") 

        # 3. External Header Controls
        ctrl_frame = tk.Frame(plot_win, bg="#2d2d30")
        ctrl_frame.pack(side="top", fill="x")
        
        show_names_var = tk.BooleanVar(value=True)
        show_legend_var = tk.BooleanVar(value=True)

        # 4. Figure Setup
        fig = Figure(figsize=(10, 6), dpi=100)
        ax = fig.add_subplot(111)

        # 5. Plotting
        prop_cycle = plt.rcParams['axes.prop_cycle']
        colors = prop_cycle.by_key()['color']
        patterns = ['-', '--', ':', '-.', (0, (3, 5, 1, 5)), (0, (5, 10)), (0, (1, 1))]

        for i, (ext, points) in enumerate(groups.items()):
            color = colors[i % len(colors)]
            style = patterns[i % len(patterns)]
            
            points.sort(key=lambda x: x['bpp'])
            lx = [p['bpp'] for p in points]
            ly = [p['score'] for p in points]
            
            ax.plot(lx, ly, linestyle=style, color=color, alpha=0.6, zorder=1)
            ax.scatter(lx, ly, color=color, s=100, edgecolor='white', linewidth=1.5, label=ext.upper(), zorder=2)

        # 6. Annotations
        text_labels = []
        for d in data:
            ann = ax.annotate(self.format_name(d['name']), 
                              xy=(d['bpp'], d['score']), 
                              xytext=(10, -5), 
                              textcoords='offset points',
                              fontsize=8, fontweight='bold', va='top', ha='left', zorder=3)
            text_labels.append(ann)

        # 7. Legend
        leg = ax.legend(loc='upper left', fontsize=9, framealpha=0.9)

        # 8. Graph Formatting
        ax.set_title("Rate-Distortion Analysis", pad=15, fontweight='bold')
        ax.set_xlabel("Bits Per Pixel (BPP)")
        ax.set_ylabel("SSIMULACRA 2 Score")
        ax.grid(True, linestyle='--', alpha=0.3)
        ax.set_ylim(45, 105)

        # Dynamic Horizontal Scale
        all_bpps = [d['bpp'] for d in data]
        if all_bpps:
            spread = max(0.1, max(all_bpps) - min(all_bpps))
            ax.set_xlim(left=max(0, min(all_bpps) - spread*0.10), right=max(all_bpps) + spread*0.20)

        # 9. Canvas & Toolbar
        canvas = FigureCanvasTkAgg(fig, master=plot_win)
        canvas.get_tk_widget().pack(side="top", fill="both", expand=True)

        toolbar_frame = tk.Frame(plot_win, bg="#2d2d30")
        toolbar_frame.pack(side="bottom", fill="x")
        toolbar = NavigationToolbar2Tk(canvas, toolbar_frame)
        toolbar.update()

        # 10. Toggle Logic
        def update_view():
            for t in text_labels: t.set_visible(show_names_var.get())
            leg.set_visible(show_legend_var.get())
            canvas.draw()

        ttk.Checkbutton(ctrl_frame, text="Show Filenames", variable=show_names_var, command=update_view).pack(side="left", padx=10)
        ttk.Checkbutton(ctrl_frame, text="Show Legend", variable=show_legend_var, command=update_view).pack(side="left", padx=10)
        
        canvas.draw()

# =============================================================================
#  CLASS: VISUAL LAB (10-MAP GRID: NLM & VARIANCE)
# =============================================================================
class VisualLabWindow(tk.Toplevel):
    def __init__(self, parent, orig_path, dist_path):
        super().__init__(parent)
        self.title("Visual Lab - Expert Image Analysis")
        self.geometry("1850x900") 
        self.configure(bg="#2d2d30")
        apply_dark_theme(self)
        
        self.gamma_mode = tk.BooleanVar(value=False)
        self.raw_diff_L = None
        self.raw_mask = None
        
        self.orig_img = self.load_image_safe(orig_path)
        self.dist_img = self.load_image_safe(dist_path)
        
        if not self.orig_img or not self.dist_img:
            messagebox.showerror("Error", "Could not load images.")
            self.destroy()
            return

        if self.orig_img.size != self.dist_img.size:
            self.dist_img = self.dist_img.resize(self.orig_img.size)

        # --- GAIN SETTINGS ---
        self.GAIN_PIXEL = 15.0   
        self.GAIN_SSIM = 20.0    
        self.GAIN_LAB_C = 20.0   
        self.GAIN_SPLIT = 40.0   

        lbl_frame = ttk.Frame(self)
        lbl_frame.pack(fill="x", pady=5)
        status_msg = "Artifact Maps (Darker = Better) | [ROW 1]: Luma/Structure | [ROW 2]: Edge/Color"
        if not CV_SUPPORT: status_msg += " | WARNING: OpenCV not found. NLM/Variance maps disabled."
        ttk.Label(lbl_frame, text=status_msg).pack()
        
        self.fig = Figure(figsize=(18, 8), facecolor="#2d2d30")
        self.fig.subplots_adjust(left=0.01, right=0.99, bottom=0.05, top=0.95, wspace=0.05, hspace=0.15)
        
        self.ax1 = self.fig.add_subplot(241); self.ax2 = self.fig.add_subplot(242) 
        self.ax3 = self.fig.add_subplot(243); self.ax4 = self.fig.add_subplot(244) 
        self.ax5 = self.fig.add_subplot(245); self.ax6 = self.fig.add_subplot(246) 
        self.ax7 = self.fig.add_subplot(247); self.ax8 = self.fig.add_subplot(248) 
        
        self.canvas = FigureCanvasTkAgg(self.fig, master=self)
        
        # 2. Pack the toolbar to the BOTTOM first
        toolbar_frame = tk.Frame(self, bg="#2d2d30")
        toolbar_frame.pack(side="bottom", fill="x")

        toolbar = NavigationToolbar2Tk(self.canvas, toolbar_frame)
        
        # 3. OVERRIDE MATPLOTLIB'S DISABLE LOGIC
        def prevent_checkered_buttons():
            if hasattr(toolbar, '_buttons'):
                for key in ['Back', 'Forward']:
                    if key in toolbar._buttons:
                        toolbar._buttons[key].configure(state='normal', bg="#2d2d30")

        toolbar.set_history_buttons = prevent_checkered_buttons
        
        prevent_checkered_buttons()

        toolbar.config(background="#2d2d30")
        for child in toolbar.winfo_children():
            try:
                child.configure(background="#2d2d30", foreground="#e1e1e1",
                                activebackground="#454545", highlightthickness=0, bd=0)
            except:
                pass
        
        toolbar.update()

        self.canvas.get_tk_widget().pack(side="top", fill="both", expand=True)
        self.fig.canvas.mpl_connect('draw_event', self.sync_button)
        
        # --- POSITION CHECKBOX ---
        self.cb_gamma = tk.Checkbutton(self, text="Logar", 
                                       variable=self.gamma_mode, 
                                       command=self.refresh_banding_map,
                                       bg='#2d2d30', 
                                       foreground='#e1e1e1',
                                       activebackground='#3e3e42', 
                                       activeforeground='white',
                                       selectcolor='#1e1e1e',
                                       highlightthickness=0, bd=0, 
                                       width=8, anchor="w")
        
        self.cb_gamma.place(x=0, y=0, anchor="ne")
        
        threading.Thread(target=self.generate_maps, daemon=True).start()

    def load_image_safe(self, path):
        if path.lower().endswith(".jxl"):
            if not os.path.exists(DJXL_EXE): return None
            tmp = path + ".tmpview.png"
            subprocess.run([DJXL_EXE, path, tmp], capture_output=True)
            if os.path.exists(tmp):
                try:
                    img = Image.open(tmp).convert("RGB")
                    img.load(); return img
                finally:
                    try: os.remove(tmp)
                    except: pass
        try: return Image.open(path).convert("RGB")
        except: return None
    
    def sync_button(self, event=None):

        try:
            bbox = self.ax4.get_window_extent()
            canvas_height = self.canvas.get_tk_widget().winfo_height()
            target_x = bbox.x1 + 22 
            target_y = canvas_height - bbox.y1 + 6
            
            self.cb_gamma.place(x=target_x, y=target_y, anchor="ne")
            self.cb_gamma.lift()
        except:
            pass
    
    def refresh_banding_map(self):

        self.cb_gamma.config(text="Gamma" if self.gamma_mode.get() else "Logar")
        
        if self.raw_diff_L is not None:
            self.render_map_4()
            self.canvas.draw_idle()

    def render_map_4(self):

        diff_L = self.raw_diff_L
        mask = self.raw_mask
        
        if diff_L is None or mask is None:
            return 
        
        # 1. SAVE CURRENT ZOOM LIMITS
        cur_xlim = self.ax1.get_xlim()
        cur_ylim = self.ax1.get_ylim()
        
        if self.gamma_mode.get():
            # --- GAMMA MODE ---
            data = diff_L.astype(np.float32)
            banding_boosted = np.sqrt(data) * 25.0
            if CV_SUPPORT:
                blur = cv2.GaussianBlur(banding_boosted, (7, 7), 0)
                banding_boosted = np.clip(banding_boosted + (banding_boosted - blur) * 4.5, 0, 100)
            
            norm = banding_boosted / 100.0
            gamma_val = 1.8
            pedestal = 2.0
            title = f"4. Gradation (Banding)"
        else:
            # --- LOG MODE ---
            banding_signal = np.power(diff_L * 15.0, 0.4)
            if CV_SUPPORT:
                blur = cv2.GaussianBlur(banding_signal, (0, 0), 1.5)
                banding_signal = banding_signal + (banding_signal - blur) * 3.2
            
            norm = np.clip(banding_signal / 9.0, 0, 1.0)
            gamma_val = 1.0
            pedestal = 2.0
            title = "4. Gradation (Banding)"

        # Common calculation
        banding_final = pedestal + (np.power(norm, gamma_val) * (100.0 - pedestal))
        banding_final *= mask
        
        if len(self.ax4.images) > 0:
            self.ax4.images[0].set_data(banding_final)
            self.ax4.set_title(title, loc='left', color="#e1e1e1")
        else:
            # First time setup
            self.ax4.imshow(banding_final, cmap='magma', vmin=0, vmax=100)
            self.ax4.set_title(title, loc='left', color="#e1e1e1")
            self.ax4.axis("off")
        
        # Re-sync button and redraw
        self.sync_button()
        self.canvas.draw_idle()
        
        # Keep the button on top
        self.cb_gamma.lift()
    
    def generate_maps(self):
        def update_ax(ax, data, title, cmap=None, vmin=None, vmax=None):
            ax.imshow(data, cmap=cmap, vmin=vmin, vmax=vmax)
            ax.set_title(title, color="#e1e1e1")
            ax.axis("off")
        img1, img2 = self.orig_img, self.dist_img
        arr1, arr2 = np.array(img1).astype(float), np.array(img2).astype(float)
        
        has_skimage = SKIMAGE_SUPPORT
        lab1, lab2 = None, None
        if has_skimage:
            lab1 = color.rgb2lab(np.array(img1) / 255.0)
            lab2 = color.rgb2lab(np.array(img2) / 255.0)

        # ==========================
        # ROW 1: LUMA / STRUCTURE
        # ==========================
        
        # 1. ABSOLUTE DIFF
        diff_abs = np.clip(np.abs(arr1 - arr2) * self.GAIN_PIXEL, 0, 255).astype(np.uint8)
        self.after(0, lambda: update_ax(self.ax1, Image.fromarray(diff_abs), f"1. Abs Diff (x{int(self.GAIN_PIXEL)})"))

        # 2. DIGITAL NOISE
        if CV_SUPPORT:
            # A. SIGNAL: Standard RGB->Grayscale
            src1 = cv2.cvtColor(np.array(img1), cv2.COLOR_RGB2GRAY)
            src2 = cv2.cvtColor(np.array(img2), cv2.COLOR_RGB2GRAY)

            # B. FILTER: Median Blur
            k_size = 3
            clean1 = cv2.medianBlur(src1, k_size)
            clean2 = cv2.medianBlur(src2, k_size)

            # C. RESIDUALS
            noise1 = src1.astype(np.int16) - clean1.astype(np.int16)
            noise2 = src2.astype(np.int16) - clean2.astype(np.int16)

            # D. ABSOLUTE DIFFERENCE
            diff_noise = np.abs(noise1 - noise2)

            # E. MASKING (Relaxed to 0.10)
            sobel = cv2.Sobel(clean1, cv2.CV_64F, 1, 1, ksize=3)
            edge_map = np.abs(sobel)
            edge_map = edge_map / (edge_map.max() + 1e-5)
            
            binary_mask = np.zeros_like(edge_map)
            binary_mask[edge_map > 0.10] = 1.0 
            
            kernel = np.ones((3,3), np.uint8)
            dilated_mask = cv2.dilate(binary_mask, kernel, iterations=1)
            final_mask = 1.0 - dilated_mask

            # F. VISUALIZATION
            masked_result = diff_noise * final_mask

            # Sensitivity: 5.0 pixel diff is max
            vis = np.clip(masked_result / 10.0, 0, 1.0)
            
            # Gamma
            gamma = 0.8
            pedestal = 2.0
            vis_final = pedestal + (np.power(vis, gamma) * (100.0 - pedestal))

            # CUSTOM COLORMAP
            colors = ["#000000", "#008B8B", "#00FFFF", "#00FF00"]
            nodes =  [0.0,       0.3,       0.6,       1.0]      
            cmap_noise = mcolors.LinearSegmentedColormap.from_list("NoiseCyanGreen", list(zip(nodes, colors)))

            self.after(0, lambda: update_ax(self.ax2, vis_final, "2. Digital Noise", cmap=cmap_noise, vmin=0, vmax=100))
        else: 
            self.after(0, lambda: self.ax2.text(0.5, 0.5, "Requires OpenCV", ha='center'))

        # 3. TEXTURE ENERGY
        if CV_SUPPORT:
            # A. INPUT: Standard Grayscale
            src1 = cv2.cvtColor(np.array(img1), cv2.COLOR_RGB2GRAY) / 255.0
            src2 = cv2.cvtColor(np.array(img2), cv2.COLOR_RGB2GRAY) / 255.0

            # B. VARIANCE MATH
            def get_variance_map(img_float):
                sq = img_float ** 2
                mu = cv2.GaussianBlur(img_float, (0, 0), 1.0)
                mu_sq = cv2.GaussianBlur(sq, (0, 0), 1.0)
                sigma2 = mu_sq - (mu ** 2)

                return np.sqrt(np.maximum(sigma2, 0))

            tex1 = get_variance_map(src1)
            tex2 = get_variance_map(src2)

            # C. DIFFERENCE
            diff_texture = np.abs(tex1 - tex2)

            # D. MASKING
            edge_threshold = 0.15
            mask = np.clip(1.0 - (tex1 / edge_threshold), 0, 1.0)
            
            # E. COMPOSITE
            final_map = diff_texture * mask

            # F. VISUALIZATION
            vis = np.clip(final_map * 40.0, 0, 1.0)
            
            pedestal = 2.0
            vis_final = pedestal + (vis * (100.0 - pedestal))

            self.after(0, lambda: update_ax(self.ax3, vis_final, "3. Texture Energy", cmap='magma', vmin=0, vmax=100))
        else: 
            self.after(0, lambda: self.ax3.text(0.5, 0.5, "Requires OpenCV", ha='center'))
        
        # 4. LUMA ERROR / BANDING
        if has_skimage:
            from skimage import filters
            
            L1, L2 = lab1[:,:,0], lab2[:,:,0]
            
            # 1. Calculate Raw Diff
            diff = np.abs(L1 - L2)
            
            # 2. DE-SPECKLE (The Fix)
            if CV_SUPPORT:
                diff_f = diff.astype(np.float32)
                diff_clean = cv2.medianBlur(diff_f, 5) 
                self.raw_diff_L = diff_clean
            else:
                self.raw_diff_L = diff

            # 3. Masking
            edge_sensitivity = 3.0 
            edges = filters.sobel(L1)
            self.raw_mask = np.clip(1.0 - (edges / edge_sensitivity), 0, 1.0)
            
            self.after(0, self.render_map_4)
        else: 
            self.after(0, lambda: self.ax4.text(0.5, 0.5, "Requires scikit-image", ha='center'))

        # ==========================
        # ROW 2: EDGE / COLOR
        # ==========================
        
        # 5. EDGE LOSS
        e1, e2 = img1.filter(ImageFilter.FIND_EDGES), img2.filter(ImageFilter.FIND_EDGES)
        diff_edge = np.clip(np.abs(np.array(e1).astype(float) - np.array(e2).astype(float)) * self.GAIN_PIXEL, 0, 255).astype(np.uint8)
        self.after(0, lambda: update_ax(self.ax5, Image.fromarray(diff_edge), f"5. Edge (x{int(self.GAIN_PIXEL)})"))

        # 6. YUV CHROMA
        yuv1, yuv2 = img1.convert("YCbCr"), img2.convert("YCbCr")
        _, cb1, cr1 = yuv1.split(); _, cb2, cr2 = yuv2.split()
        def diff_ch(c1, c2):
            return Image.fromarray(np.clip(np.abs(np.array(c1).astype(float) - np.array(c2).astype(float)) * 20.0, 0, 255).astype(np.uint8))
        map_chroma = Image.merge("RGB", (diff_ch(cr1, cr2), diff_ch(cb1, cb2), Image.new("L", img1.size, 0)))
        self.after(0, lambda: update_ax(self.ax6, map_chroma, "6. YUV Chroma (x20)"))

        # 7. CIELAB TOTAL
        if has_skimage:
            ab1, ab2 = lab1[:, :, 1:], lab2[:, :, 1:]
            delta_ab = np.sqrt(np.sum((ab1 - ab2) ** 2, axis=2))
            self.after(0, lambda: update_ax(self.ax7, delta_ab, "7. CIELAB Chroma [0-10]", cmap='magma', vmin=0, vmax=10))
        else: self.after(0, lambda: self.ax7.text(0.5, 0.5, "Requires scikit-image", ha='center'))

        # 8. CIELAB SPLIT
        if has_skimage:
            ab1, ab2 = lab1[:, :, 1:], lab2[:, :, 1:]
            C1, C2 = np.sqrt(np.sum(ab1**2, axis=2)), np.sqrt(np.sum(ab2**2, axis=2))
            dC = np.abs(C1 - C2)
            dH = np.sqrt(np.maximum(0, np.sum((ab1 - ab2)**2, axis=2) - dC**2))
            
            map_C = np.clip(dC * self.GAIN_SPLIT, 0, 255).astype(np.uint8)
            map_H = np.clip(dH * self.GAIN_SPLIT, 0, 255).astype(np.uint8)
            blank = np.zeros_like(map_C)

            combined = np.dstack((map_C, blank, map_H))
            self.after(0, lambda: update_ax(self.ax8, combined, f"8. CIELAB Split (x{int(self.GAIN_SPLIT)})"))
        else: self.after(0, lambda: self.ax8.text(0.5, 0.5, "Requires scikit-image", ha='center'))

        def sync_all_axes():
            sub_axes = [self.ax2, self.ax3, self.ax4, self.ax5, self.ax6, self.ax7, self.ax8]
            for ax in sub_axes:
                ax.sharex(self.ax1)
                ax.sharey(self.ax1)

        # Schedule it to run on the Main Thread
        self.after(0, sync_all_axes)
        self.after(0, self.canvas.draw_idle)

# =============================================================================
#  CLASS: BATCH METRICS LAB (The New Optimizer)
# =============================================================================
class BatchMetricsLabWindow(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Batch Metrics")
        self.geometry("900x600")
        self.configure(bg="#2d2d30")
        apply_dark_theme(self)
        
        # --- 1. THE DATA TABLE ---
        cols = ("Filename", "Codec", "Setting")
        self.tree = ttk.Treeview(self, columns=cols, show='headings', selectmode='extended')
        
        self.tree.heading("Filename", text="CSV Filename")
        self.tree.heading("Codec", text="Codec")
        self.tree.heading("Setting", text="Setting / Quality")
        
        self.tree.column("Filename", width=400)
        self.tree.column("Codec", width=100, anchor="center")
        self.tree.column("Setting", width=100, anchor="center")
        
        self.tree.pack(fill="both", expand=True, padx=10, pady=10)

        # --- ENABLE DRAG AND DROP ---
        if DND_SUPPORT:
            self.tree.drop_target_register(DND_FILES)
            self.tree.dnd_bind('<<Drop>>', self.drop_handler)

        # --- 2. DATA CONTROLS ---
        frame_ctrl = ttk.Frame(self)
        frame_ctrl.pack(fill="x", padx=10, pady=(0, 10))
        
        ttk.Button(frame_ctrl, text="+ Add CSVs", command=self.add_csvs).pack(side="left", padx=5)
        ttk.Button(frame_ctrl, text="- Remove Selected", command=self.remove_selected).pack(side="left", padx=5)
        ttk.Button(frame_ctrl, text="↑", width=3, command=lambda: self.move_item(-1)).pack(side="left", padx=2)
        ttk.Button(frame_ctrl, text="↓", width=3, command=lambda: self.move_item(1)).pack(side="left", padx=2)
        ttk.Label(frame_ctrl, text="(Double-click a row to edit Codec/Setting)", font=("Segoe UI", 8, "italic")).pack(side="left", padx=15)

        # --- 3. THE PLOT BUTTONS ---
        frame_plots = ttk.LabelFrame(self, text=" Plot Types ", padding=10)
        frame_plots.pack(fill="x", padx=10, pady=10)
        
        # A. 2 CSV Analysis
        ttk.Label(frame_plots, text="2 CSV", font=("Segoe UI", 9, "bold")).pack(side="left", padx=(0,5))
        ttk.Button(frame_plots, text="Cloud", command=lambda: self.run_plot("delta")).pack(side="left", padx=5)
        
        ttk.Separator(frame_plots, orient="vertical").pack(side="left", fill="y", padx=15)
        
        # B. 2+ CSV Analysis
        ttk.Label(frame_plots, text="2+ CSV", font=("Segoe UI", 9, "bold")).pack(side="left", padx=(0,5))
        ttk.Button(frame_plots, text="BD-Rate Curve", command=lambda: self.run_plot("bd_rate")).pack(side="left", padx=5)
        ttk.Button(frame_plots, text="Boxenplot", command=lambda: self.run_plot("boxen")).pack(side="left", padx=5)
        ttk.Button(frame_plots, text="ECDF", command=lambda: self.run_plot("ecdf")).pack(side="left", padx=5)
        
        ttk.Separator(frame_plots, orient="vertical").pack(side="left", fill="y", padx=15)
        
        # 3+ CSV Section
        ttk.Label(frame_plots, text="3+ CSV", font=("Segoe UI", 9, "bold")).pack(side="left", padx=(0,5))
        ttk.Button(frame_plots, text="Galaxy", command=lambda: self.run_plot("global_cloud")).pack(side="left", padx=5)
        
        self.tree.bind("<Double-1>", self.on_double_click)

    def drop_handler(self, event):
        files = self.tk.splitlist(event.data)
        for f in files:
            if f.lower().endswith(".csv"):
                self.add_single_file(f)

    def add_csvs(self):
        files = filedialog.askopenfilenames(filetypes=[("Metrics CSV", "*_metrics.csv"), ("All CSV", "*.csv")])
        if files:
            for f in files: self.add_single_file(f)

    def add_single_file(self, f):
        fname = os.path.basename(f)
        clean_name = fname.lstrip('!')
        
        parts = clean_name.split('_')
        guess_codec = parts[0] if len(parts) > 0 else "Unknown"
        guess_setting = parts[1] if len(parts) > 1 and "metrics" not in parts[1] else "Default"
        self.tree.insert("", "end", values=(f, guess_codec, guess_setting))

    def remove_selected(self):
        for item in self.tree.selection():
            self.tree.delete(item)
            
    def move_item(self, direction):
        items = self.tree.selection()
        if not items: return
        
        items_to_move = items if direction == -1 else reversed(items)
        
        for item in items_to_move:
            idx = self.tree.index(item)
            new_idx = idx + direction

            if 0 <= new_idx < len(self.tree.get_children()):
                self.tree.move(item, '', new_idx)

    def on_double_click(self, event):
        item = self.tree.selection()[0]
        values = self.tree.item(item, "values")
        
        edit_win = tk.Toplevel(self)
        edit_win.title("Edit Metadata")
        edit_win.geometry("300x150")
        edit_win.configure(bg="#2d2d30")
        apply_dark_theme(edit_win)
        
        ttk.Label(edit_win, text="Codec Name:").pack(pady=5)
        ent_codec = ttk.Entry(edit_win); ent_codec.insert(0, values[1]); ent_codec.pack()
        
        ttk.Label(edit_win, text="Setting/Value:").pack(pady=5)
        ent_setting = ttk.Entry(edit_win); ent_setting.insert(0, values[2]); ent_setting.pack()
        
        def save():
            self.tree.item(item, values=(values[0], ent_codec.get(), ent_setting.get()))
            edit_win.destroy()
            
        ttk.Button(edit_win, text="Save", command=save).pack(pady=10)
        
    def get_data_from_tree(self):

        datasets = []
        for item in self.tree.get_children():
            vals = self.tree.item(item, "values")
            path, codec, setting = vals[0], vals[1], vals[2]
            
            data_points = []
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    reader = csv.DictReader(f)
                    for row in reader:
                        # robustness: try/except for bad lines
                        try:

                            entry = {
                                "File": row.get("Filename", "?"),
                                "BPP": float(row.get("BPP", 0)),
                                "SSIM": float(row.get("SSIM2", -1)),
                                "Butter": float(row.get("Butter_Peak", -1)),
                                "Butter3N": float(row.get("Butter_3Norm", -1))
                            }
                            if entry["SSIM"] > 0:
                                data_points.append(entry)
                        except: continue
            except Exception as e:
                print(f"Error reading {path}: {e}")
                continue

            if data_points:
                datasets.append({
                    "path": path,
                    "codec": codec,
                    "setting": setting,
                    "data": data_points
                })
        return datasets

    def run_plot(self, mode):
        if not MPL_SUPPORT: return
        datasets = self.get_data_from_tree()
        if not datasets:
            messagebox.showwarning("Empty", "No valid data found in CSVs.")
            return

        # --- ROUTING ---
        if mode == "delta":
            self.plot_delta_cloud(datasets)
        elif mode == "bd_rate":
            self.plot_bd_rate(datasets)
        elif mode == "boxen":
            self.plot_boxen(datasets)
        elif mode == "ecdf":
            self.plot_ecdf(datasets)
        elif mode == "global_cloud":
            self.plot_global_cloud(datasets)
            
    # ============================================
    # 1. DELTA CLOUD (1 vs 1)
    # ============================================
    def plot_delta_cloud(self, datasets):
        if len(datasets) != 2:
            messagebox.showerror("Error", "Delta Cloud requires exactly 2 CSVs (A vs B).")
            return

        d1, d2 = datasets[0], datasets[1]
        
        # Match files by Name
        d2_map = {x["File"]: x for x in d2["data"]}
        
        deltas_bpp = []
        deltas_ssim = []
        names = []

        for p1 in d1["data"]:
            name = p1["File"]
            if name in d2_map:
                p2 = d2_map[name]

                deltas_bpp.append(p1["BPP"] - p2["BPP"])
                deltas_ssim.append(p1["SSIM"] - p2["SSIM"])
                names.append(name)

        if not deltas_bpp:
            messagebox.showerror("Error", "No matching filenames found.")
            return

        count = len(deltas_bpp)

        # If huge dataset: smaller dots, higher transparency
        if count > 2000:
            dot_size = 10
            dot_alpha = 0.3
        elif count > 500:
            dot_size = 20
            dot_alpha = 0.5
        else:
            dot_size = 40
            dot_alpha = 0.7

        fig = Figure(figsize=(9, 9))
        ax = fig.add_subplot(111)
        ax.set_title(f"Delta Cloud: {d1['codec']} vs {d2['codec']}", pad=25)

        # 1. CARTESIAN SPINES
        ax.spines['left'].set_position('zero')
        ax.spines['bottom'].set_position('zero')
        ax.spines['right'].set_color('none')
        ax.spines['top'].set_color('none')

        # 2. CALCULATE SYMMETRIC LIMITS
        max_x = max(abs(min(deltas_bpp)), abs(max(deltas_bpp)))
        max_y = max(abs(min(deltas_ssim)), abs(max(deltas_ssim)))
        
        limit_x = max_x * 1.1 if max_x > 0 else 0.1
        limit_y = max_y * 1.1 if max_y > 0 else 1.0

        ax.set_xlim(-limit_x, limit_x)
        ax.set_ylim(-limit_y, limit_y)

        # 3. QUADRANT LABELS
        style = dict(fontsize=9, color='gray', alpha=0.5, fontweight='bold')
        ax.text(limit_x*0.9, limit_y*0.9, "Larger & Better", ha='right', va='top', **style)
        ax.text(-limit_x*0.9, limit_y*0.9, "Smaller & Better", ha='left', va='top', **style) # The "Magic" Quadrant
        ax.text(limit_x*0.9, -limit_y*0.9, "Larger & Worse", ha='right', va='bottom', **style)
        ax.text(-limit_x*0.9, -limit_y*0.9, "Smaller & Worse", ha='left', va='bottom', **style)

        # 4. PLOT SCATTER
        sc = ax.scatter(deltas_bpp, deltas_ssim, alpha=dot_alpha, s=dot_size, c='navy', edgecolors='white', linewidth=0.5)

        # 5. LABELS
        ax.set_xlabel(f"Δ Bits Per Pixel ({d1['codec']} - {d2['codec']})")
        ax.set_ylabel(f"Δ SSIM 2 Score ({d1['codec']} - {d2['codec']})")
        
        # Force them to the window edges
        ax.xaxis.set_label_coords(0.5, -0.07)
        ax.yaxis.set_label_coords(-0.09, 0.5)
        
        # Grid settings matching the reference
        ax.grid(True, which='both', linestyle='-', alpha=0.2)

        # Hover Logic
        def hover(event):
            if event.inaxes == ax:
                cont, ind = sc.contains(event)
                if cont:
                    idx = ind["ind"][0]
                    fig.canvas.toolbar.set_message(f"{names[idx]} | BPP: {deltas_bpp[idx]:.4f} | SSIM: {deltas_ssim[idx]:.4f}")

        fig.canvas.mpl_connect("motion_notify_event", hover)
        
        self.show_plot_window(fig, "Delta Cloud Analysis")

    # ============================================
    # 2. BD-RATE (Efficiency Curves)
    # ============================================
    def plot_bd_rate(self, datasets):
        groups = {}
        all_bpp = []
        for ds in datasets:
            c = ds['codec']
            if c not in groups: groups[c] = []
            avg_bpp = statistics.mean([x['BPP'] for x in ds['data']])
            avg_ssim = statistics.mean([x['SSIM'] for x in ds['data']])
            groups[c].append((avg_bpp, avg_ssim, ds['setting']))
            all_bpp.append(avg_bpp)

        fig = Figure(figsize=(12, 6))
        ax = fig.add_subplot(111)
        fig.subplots_adjust(right=0.78, left=0.08, bottom=0.12, top=0.90)
        
        for codec, points in groups.items():
            points.sort(key=lambda x: x[0])
            x_vals, y_vals = [p[0] for p in points], [p[1] for p in points]
            line, = ax.plot(x_vals, y_vals, marker='o', linewidth=2, markersize=6, label=codec)
            for p in points:
                ax.annotate(p[2], (p[0], p[1]), xytext=(0, 5), textcoords='offset points', fontsize=8, color=line.get_color())

        ax.set_title("Rate-Distortion Curves (Efficiency)")
        ax.set_xlabel("Average Bits Per Pixel (BPP)")
        ax.set_ylabel("Average SSIM 2 Score")
        ax.grid(True, linestyle='--', alpha=0.3)
        ax.legend(loc='upper left', bbox_to_anchor=(1.02, 1.0), frameon=True, fontsize=9, edgecolor='#aaaaaa')
        
        ax.set_ylim(45, 105) 
        ax.set_yticks(range(50, 105, 5)) 

        if all_bpp:
            bmin, bmax = min(all_bpp), max(all_bpp)
            margin = (bmax - bmin) * 0.2 if bmax != bmin else 0.1
            ax.set_xlim(bmin - margin, bmax + margin)

        ax.text(0.02, 0.98, "Better Efficiency ↗", transform=ax.transAxes, ha='left', va='top', fontsize=10, style='italic', alpha=0.6)
        self.show_plot_window(fig, "BD-Rate Analysis")
    
    # ============================================
    # 4. BOXENPLOT
    # ============================================
    def plot_boxen(self, datasets):
        from matplotlib import patheffects 

        fig = Figure(figsize=(12, 6))
        ax = fig.add_subplot(111)
        labels, data_list = [], []
        for ds in datasets:
            clean_data = [x['Butter'] for x in ds['data'] if x['Butter'] >= 0]
            if clean_data:
                data_list.append(clean_data)
                labels.append(f"{ds['codec']}\n{ds['setting']}")

        if not data_list: return

        parts = ax.violinplot(data_list, showmeans=False, showmedians=False, showextrema=False)
        for pc in parts['bodies']:
            pc.set_facecolor('#dddddd'); pc.set_alpha(0.6)

        diamond_style = dict(marker='D', markerfacecolor='#e74c3c', markersize=4, markeredgecolor='black')
        ax.boxplot(data_list, tick_labels=labels, patch_artist=True, 
                   boxprops=dict(facecolor='none', edgecolor='#2980b9', linewidth=1.5),
                   medianprops=dict(color='#c0392b', linewidth=2),
                   flierprops=diamond_style)

        ax.set_title("Artifact Distribution (Fail Tail Analysis)", pad=15, fontweight='bold')
        ax.set_ylabel("Butteraugli Peak Distance (Lower is Better)", fontweight='bold')
        ax.yaxis.grid(True, linestyle=':', color='#cccccc', alpha=0.7)
        
        ax.axhline(1.5, color='#27ae60', linestyle='--', linewidth=1.2, alpha=0.8, zorder=1)
        
        txt = ax.text(0.07, 1.35, "Vis. Los.", color='#27ae60', 
                      fontsize=8, fontweight='bold', va='center', ha='right',
                      transform=ax.get_yaxis_transform())
        
        txt.set_path_effects([patheffects.withStroke(linewidth=3, foreground='white')])

        self.show_plot_window(fig, "Box Violin Analysis")
    
    # ============================================
    # 5. ECDF
    # ============================================
    def plot_ecdf(self, datasets):
        from matplotlib.offsetbox import AnchoredText, VPacker, TextArea, AnnotationBbox, DrawingArea
        from matplotlib.lines import Line2D

        fig = Figure(figsize=(12, 7), facecolor='#ebebeb') 
        ax = fig.add_subplot(111, facecolor='white')
        fig.subplots_adjust(right=0.75, left=0.08, bottom=0.12, top=0.90)

        plot_data = []
        for ds in datasets:
            data = [x['SSIM'] for x in ds['data'] if x['SSIM'] > 0]
            if data:
                mu = statistics.mean(data)
                sigma = statistics.stdev(data) if len(data) > 1 else 0
                plot_data.append({'mu': mu, 'sigma': sigma, 'n': len(data), 'ds': ds, 'raw': np.sort(data)})
        
        plot_data.sort(key=lambda x: x['mu'], reverse=False)

        stats_text = " Mean    StDev   N \n" + "-"*19 + "\n"
        for d in plot_data:
            yvals = np.arange(len(d['raw'])) / float(len(d['raw']) - 1) * 100
            ax.step(d['raw'], yvals, label=f"{d['ds']['codec']} {d['ds']['setting']}", where='post', linewidth=2)
            stats_text += f"{d['mu']:>6.3f}  {d['sigma']:>6.4f}  {d['n']:>3}\n"

        ax.set_title("Empirical CDF Analysis", pad=20, fontweight='bold', fontsize=14)
        ax.set_xlabel("Data (SSIM 2 Score)", fontweight='bold')
        ax.set_ylabel("Percent", fontweight='bold')
        ax.grid(True, linestyle='-', color='#dddddd', alpha=0.8, zorder=1)
        ax.axvspan(50, 60, color='#ff0000', alpha=0.12, zorder=2)
        ax.axvline(60, color='red', linestyle='--', linewidth=1, alpha=0.5, zorder=4)

        leg = ax.legend(loc='upper left', frameon=False, prop={'family': 'Segoe UI', 'size': 9})
        legend_content = leg.get_children()[0] 
        leg.remove() 

        stats_area = TextArea(stats_text, textprops=dict(size=9, family='monospace'))
        
        # Create Graphical Line
        line_canvas = DrawingArea(100, 20)  
        line_canvas.add_artist(Line2D([0, 100], [10, 10], color='#666666', linewidth=1))

        vbox = VPacker(children=[legend_content, line_canvas, stats_area], 
                       align="left", 
                       pad=0, 
                       sep=5) 

        # ANCHOR THEM
        anchored_box = AnnotationBbox(vbox, xy=(1, 0.5), xycoords='axes fraction',
                                      xybox=(25, 0), boxcoords="offset points",
                                      box_alignment=(0, 0.5),
                                      frameon=True,
                                      bboxprops=dict(facecolor='white', edgecolor='#aaaaaa', 
                                                     boxstyle="round,pad=1.0"))
        
        ax.add_artist(anchored_box)
        
        ax.set_xlim(50, 100.5)
        ax.set_ylim(-2, 105)
        self.show_plot_window(fig, "ECDF Reliability Analysis")

# ============================================
    # NEW: GLOBAL DENSITY CLOUD
    # ============================================
    def plot_global_cloud(self, datasets):
        import numpy as np
        from scipy.stats import gaussian_kde
        import matplotlib.colors as mcolors

        # 1. DATA PREP
        unique_codecs = sorted(list(set(ds['codec'] for ds in datasets)))
        prop_colors = plt.cm.Set1(np.linspace(0, 1, len(unique_codecs)))
        codec_map = dict(zip(unique_codecs, prop_colors))

        all_x, all_y = [], []
        for ds in datasets:
            for p in ds['data']:
                b3n = p['Butter3N'] if p['Butter3N'] >= 0 else 0
                score = p['SSIM'] - (p['Butter'] * 4.0) - (b3n * 5.0)
                all_x.append(p['BPP']); all_y.append(score)

        if not all_x: return
        xmin, xmax = min(all_x), max(all_x)
        ymin, ymax = min(all_y), max(all_y)
        padx, pady = (xmax-xmin)*0.2, (ymax-ymin)*0.2
        extent = [xmin-padx, xmax+padx, ymin-pady, ymax+pady]

        # 2. FIGURE SETUP
        fig = Figure(figsize=(14, 11), facecolor='#ffffff')
        gs = fig.add_gridspec(2, 2, width_ratios=[4, 1], height_ratios=[1, 4],
                              left=0.1, right=0.9, bottom=0.1, top=0.9,
                              wspace=0.02, hspace=0.02)

        ax_main = fig.add_subplot(gs[1, 0])
        ax_xhist = fig.add_subplot(gs[0, 0], sharex=ax_main)
        ax_yhist = fig.add_subplot(gs[1, 1], sharey=ax_main)
        ax_xhist.axis('off'); ax_yhist.axis('off')
        
        # Create a high-res evaluation grid
        xi, yi = np.mgrid[extent[0]:extent[1]:150j, extent[2]:extent[3]:150j]

        # 3. PLOT INDIVIDUAL CLOUDS
        for ds in datasets:
            local_x = [p['BPP'] for p in ds['data']]
            local_y = [p['SSIM'] - (p['Butter'] * 4.0) - (p.get('Butter3N', 0) * 5.0) for p in ds['data']]
            
            x, y = np.array(local_x), np.array(local_y)
            color = codec_map[ds['codec']]
            
            if len(x) < 3: continue

            try:
                # KDE logic
                positions = np.vstack([xi.ravel(), yi.ravel()])
                kernel = gaussian_kde(np.vstack([x, y]))
                zi = np.reshape(kernel(positions).T, xi.shape)

                glow_levels = np.linspace(zi.max()*0.00, zi.max(), 10)
                ring_levels = [zi.max()*0.5, zi.max()*0.75, zi.max()*0.9]
                ax_main.contourf(xi, yi, zi, levels=glow_levels, cmap=mcolors.LinearSegmentedColormap.from_list("", [(0,0,0,0), color, color, color, color]), alpha=0.2, zorder=3)
                
                ax_main.contour(xi, yi, zi, levels=ring_levels, colors=[color], alpha=0.8, linewidths=0.8, zorder=4)

                # --- MARGINAL HILLS ---
                from scipy.stats import gaussian_kde as kde1d
                # Top Hills
                tx = np.linspace(xmin-padx, xmax+padx, 300)
                kx = kde1d(x)(tx)
                ax_xhist.fill_between(tx, kx, color=color, alpha=0.3)
                ax_xhist.plot(tx, kx, color=color, linewidth=1.5)

                # Right Hills
                ty = np.linspace(ymin-pady, ymax+pady, 300)
                ky = kde1d(y)(ty)
                ax_yhist.fill_betweenx(ty, 0, ky, color=color, alpha=0.3)
                ax_yhist.plot(ky, ty, color=color, linewidth=1.5)

            except Exception as e:
                print(f"Error plotting {ds['codec']}: {e}")
                ax_main.scatter(x, y, color=color, s=5, alpha=0.3, label=ds['codec'])

            # Proxy for Legend
            ax_main.scatter([None], [None], color=color, label=ds['codec'], s=100)

        # 4. FINAL CLEANUP
        ax_main.set_xlabel("Bits Per Pixel (BPP) [Cost]", fontweight='bold', labelpad=15)
        ax_main.set_ylabel("Gravity Score (SSIM2 Penalized by Butteraugli) [Value]", fontweight='bold', labelpad=15)
        ax_main.grid(True, linestyle='--', alpha=0.1, zorder=1)

        ax_leg = fig.add_subplot(gs[0, 1])
        ax_leg.axis('off')
        
        handles, labels = ax_main.get_legend_handles_labels()
        by_label = dict(zip(labels, handles)) 

        ax_leg.legend(by_label.values(), by_label.keys(), loc='lower left', frameon=False, fontsize=9)
        
        ax_main.text(0.02, 0.98, "Efficiency ↑", transform=ax_main.transAxes, 
                     va='top', color='#2ecc71', alpha=0.7, style='italic', fontsize=10)
        ax_main.text(0.98, 0.02, "Dirty ↘", transform=ax_main.transAxes, 
                     ha='right', color='#e74c3c', alpha=0.7, style='italic', fontsize=10)
        
        # Standardize axis limits
        ax_main.set_xlim(extent[0], extent[1])
        ax_main.set_ylim(extent[2], extent[3])
        ax_xhist.set_xlim(extent[0], extent[1])
        ax_yhist.set_ylim(extent[2], extent[3])

        self.show_plot_window(fig, "HistKDE")
    
    def show_plot_window(self, fig, title):
        win = tk.Toplevel(self)
        win.title(title)
        canvas = FigureCanvasTkAgg(fig, master=win)
        canvas.get_tk_widget().pack(fill="both", expand=True)
        toolbar = NavigationToolbar2Tk(canvas, win)
        toolbar.update()

# =============================================================================
#  CLASS: PLOT +
# =============================================================================
class PlotPlusWindow(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Plot + (Single CSV Advanced Analysis)")
        self.geometry("600x520")
        self.configure(bg="#2d2d30")
        apply_dark_theme(self)
        
        # --- 1. THE FILE LIST ---
        lbl = ttk.Label(self, text="Put the CSVs Here and Select One to Analyze:", font=("Segoe UI", 10, "bold"))
        lbl.pack(pady=(15, 5))
        
        self.tree = ttk.Treeview(self, columns=("Path"), show='headings', height=8)
        self.tree.heading("Path", text="CSV File Path")
        self.tree.pack(fill="both", expand=True, padx=20, pady=5)
        
        if DND_SUPPORT:
            self.tree.drop_target_register(DND_FILES)
            self.tree.dnd_bind('<<Drop>>', self.handle_drop)

        # --- 2. CONTROLS ---
        ctrl = tk.Frame(self, bg="#2d2d30")
        ctrl.pack(fill="x", padx=20, pady=10)
        ttk.Button(ctrl, text="+ Add CSV", command=self.add_csv).pack(side="left")
        ttk.Button(ctrl, text="- Remove", command=self.remove_csv).pack(side="left", padx=5)
        
        ttk.Label(ctrl, text="  Title:").pack(side="left")
        self.ent_title_override = ttk.Entry(ctrl, width=25)
        self.ent_title_override.pack(side="left", padx=5)

        # --- 3. PLOT ACTIONS ---
        plot_frame = ttk.LabelFrame(self, text=" Plot Types ", padding=10)
        plot_frame.pack(fill="x", padx=20, pady=15)
        
        ttk.Button(plot_frame, text="Heatmap (<1k IMG)", command=lambda: self.run_report("strip")).pack(side="left", expand=True, fill="x", padx=5)
        ttk.Button(plot_frame, text="Heatmap Carpet (>1k IMG)", command=lambda: self.run_report("carpet")).pack(side="left", expand=True, fill="x", padx=5)

    def handle_drop(self, event):
        files = self.tk.splitlist(event.data)
        for f in files:
            if f.lower().endswith(".csv"): self.tree.insert("", "end", values=(f,))

    def add_csv(self):
        f = filedialog.askopenfilename(filetypes=[("Metrics CSV", "*.csv")])
        if f: self.tree.insert("", "end", values=(f,))

    def remove_csv(self):
        for item in self.tree.selection(): self.tree.delete(item)

    def load_data(self):
        selected = self.tree.selection()
        
        # 2. AUTO-SELECT LOGIC: 
        if not selected:
            all_items = self.tree.get_children()
            if all_items:
                selected = (all_items[0],) 
                self.tree.selection_set(all_items[0])
            else:
                messagebox.showwarning("Warning", "Please add a CSV file to the list first.")
                return None
        
        path = self.tree.item(selected[0], "values")[0]
        data = {"names": [], "ssim": [], "b_max": [], "b_3n": []}
        
        try:
            with open(path, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    if "SSIM2" in row:
                        data["names"].append(row.get("Filename", "Unknown"))
                        data["ssim"].append(float(row.get("SSIM2", -1)))
                        data["b_max"].append(float(row.get("Butter_Peak", -1)))
                        data["b_3n"].append(float(row.get("Butter_3Norm", -1)))
            
            if not data["names"]:
                messagebox.showerror("Error", "CSV is empty or formatted incorrectly.")
                return None
                
            return data
        except Exception as e:
            messagebox.showerror("Error", f"Could not parse CSV:\n{e}")
            return None

    def run_report(self, mode):
        d = self.load_data()
        if not d: return
        
        if mode == "strip":
            self.show_heatmap(d, carpet=False)
        elif mode == "carpet":
            self.show_heatmap(d, carpet=True)
    
    def show_heatmap(self, d, carpet):
        from matplotlib.figure import Figure
        if not MPL_SUPPORT:
            messagebox.showwarning("Missing Library", "Matplotlib not found.")
            return
            
        names, ssim, b_max, b_3n = d["names"], d["ssim"], d["b_max"], d["b_3n"]
        
        plt.close('all') 
        # ==========================================
        # CARPET VIEW
        # ==========================================
        if carpet:
            fig = Figure(figsize=(15, 8))
            custom_t = self.ent_title_override.get().strip()
            fig.suptitle(custom_t if custom_t else "Carpet Heatmap", fontsize=14, fontweight='bold', y=0.97)
            
            gs_top = fig.add_gridspec(1, 1, top=0.88, bottom=0.60, left=0.08, right=0.90)
            gs_bot = fig.add_gridspec(2, 1, top=0.55, bottom=0.10, left=0.08, right=0.90, hspace=0.05)
            
            ax1 = fig.add_subplot(gs_top[0])
            ax2 = fig.add_subplot(gs_bot[0])
            ax3 = fig.add_subplot(gs_bot[1])
            
            # Grid Calculations
            ROWS = 15
            total = len(names)
            cols = -(-total // ROWS)
            pad_len = (ROWS * cols) - total
            def to_grid(lst): return np.array(lst + [np.nan]*pad_len).reshape((ROWS, cols))

            # Draw Heatmaps
            im1 = ax1.imshow(to_grid(ssim), cmap='Spectral', aspect='auto', vmin=50, vmax=100)
            ax1.set_ylabel("SSIM 2", fontweight='bold'); ax1.set_xticks([]); ax1.set_yticks([])

            im2 = ax2.imshow(to_grid(b_max), cmap='Spectral_r', aspect='auto', vmin=0, vmax=3.0)
            ax2.set_ylabel("Butter Peak", fontweight='bold'); ax2.set_xticks([]); ax2.set_yticks([])

            im3 = ax3.imshow(to_grid(b_3n), cmap='Spectral_r', aspect='auto', vmin=0, vmax=3.0)
            ax3.set_ylabel("Butter 3N", fontweight='bold'); ax3.set_xticks([]); ax3.set_yticks([])

            fig.colorbar(im1, ax=ax1, fraction=0.01).set_label('Quality')
            fig.colorbar(im3, ax=[ax2, ax3], fraction=0.01).set_label('Distance')

            # Carpet Hover Logic
            def on_hover_c(event):
                if event.inaxes in [ax1, ax2, ax3]:
                    try:
                        c = int(round(event.xdata)); r = int(round(event.ydata))
                        idx = r * cols + c
                        if idx < total:
                            msg = f"Idx:{idx} | {names[idx]} | SSIM:{ssim[idx]:.2f} | B_Max:{b_max[idx]:.2f} | B_3N:{b_3n[idx]:.2f}"
                            fig.canvas.toolbar.set_message(msg)
                    except: pass
            canvas = self.show_plot_window(fig, custom_t if custom_t else "Carpet Heatmap")
            canvas.mpl_connect("motion_notify_event", on_hover_c)

        else:
            fig = Figure(figsize=(15, 4.5))
            ax1 = fig.add_subplot(211)
            ax2 = fig.add_subplot(212)
            fig.set_tight_layout(True)
            
            # Canvas Title (High)
            custom_t = self.ent_title_override.get().strip()
            fig.suptitle(custom_t if custom_t else "Strip Heatmap", fontsize=14, fontweight='bold', y=0.97)

            fig.subplots_adjust(hspace=0.4, right=0.98, left=0.1, bottom=0.12, top=0.82)

            # Plot SSIM
            ssim_data = np.array([ssim])
            im1 = ax1.imshow(ssim_data, cmap='Spectral', aspect='auto', vmin=50, vmax=100)
            ax1.set_yticks([0]); ax1.set_yticklabels(["SSIM 2"], fontweight='bold'); ax1.set_xticks([])
            fig.colorbar(im1, ax=ax1, fraction=0.046, pad=0.04).set_label('Quality')

            # Plot Butter
            butter_data = np.array([b_max, b_3n])
            im2 = ax2.imshow(butter_data, cmap='Spectral_r', aspect='auto', vmin=0, vmax=3.0)
            ax2.set_yticks([0, 1]); ax2.set_yticklabels(["Butter Peak", "Butter 3N"], fontweight='bold'); ax2.set_xticks([])
            fig.colorbar(im2, ax=ax2, fraction=0.046, pad=0.04).set_label('Distance')

            ax1.format_coord = lambda x, y: ""
            ax2.format_coord = lambda x, y: ""

            # Strip Hover Logic
            def hover(event):
                if event.inaxes in [ax1, ax2]:
                    try:
                        col = int(round(event.xdata))
                        if 0 <= col < len(names):
                            n = names[col]
                            s = ssim[col]
                            bm = b_max[col]
                            b3 = b_3n[col]
                            msg = f"File: {n}  |  SSIM: {s:.2f}  |  Butter Peak: {bm:.2f}  |  Butter 3N: {b3:.2f}"
                            fig.canvas.toolbar.set_message(msg)
                    except: fig.canvas.toolbar.set_message("")
            
            canvas = self.show_plot_window(fig, custom_t if custom_t else "Strip Heatmap")
            canvas.mpl_connect("motion_notify_event", hover)
        
    def show_plot_window(self, fig, title):
        win = tk.Toplevel(self)
        win.title(title)
        
        main_icon = getattr(self, 'app_icon', None) or getattr(self.master, 'app_icon', None)
        if main_icon:
            win.iconphoto(True, main_icon)

        canvas = FigureCanvasTkAgg(fig, master=win)
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        toolbar = NavigationToolbar2Tk(canvas, win)
        toolbar.update()
        
        # This allows the plot to fill the window
        canvas.draw()
        
        return canvas  
        
# =============================================================================
#  MAIN GUI
# =============================================================================
class MetricToolGUI(BaseClass):
    def __init__(self):
        super().__init__()
        self.title("Image Metric Tool")
        self.geometry("900x750")
        try:
            self.app_icon = tk.PhotoImage(data=ICON_DATA)
            self.iconphoto(True, self.app_icon)
        except Exception as e:
            print(f"Icon Error: {e}")
            
        self.configure(bg="#2d2d30")
        self.current_heatmap = None
        self.last_results = [] 
        apply_dark_theme(self)
        self.batch_thread_count = tk.IntVar(value=0)
        
        # --- THEME COLORS ---
        BG_MAIN = "#2d2d30"     
        BG_SURFACE = "#3e3e42"  
        ACCENT_BLUE = "#0078d4" 
        ACCENT_PURPLE = "#68217a"
        TEXT_COLOR = "#e1e1e1"  

        # --- STYLES  ---
        style = ttk.Style()
        style.theme_use('clam')

        # 1. THE LAYOUT
        style.layout("Vertical.TScrollbar", [
            ('Vertical.Scrollbar.trough', {'children': [
                ('Vertical.Scrollbar.uparrow', {'side': 'top', 'sticky': ''}),
                ('Vertical.Scrollbar.downarrow', {'side': 'bottom', 'sticky': ''}),
                ('Vertical.Scrollbar.thumb', {'expand': '1', 'sticky': 'nswe'})
            ], 'sticky': 'ns'})
        ])

        # 2. THE LOOK
        TEAL_MAIN   = "#1a4d75"  
        TEAL_HOVER  = "#246191" 
        TEAL_PRESS  = "#003a66" 
        TRACK_COLOR = "black" 
        ARROW_COLOR = "black"   

        style.configure("Vertical.TScrollbar",
                        grabanywhere=0,
                        troughcolor=TRACK_COLOR, 
                        background=TEAL_MAIN,    
                        bordercolor=TRACK_COLOR,
                        darkcolor=TEAL_MAIN,   
                        lightcolor=TEAL_MAIN,   
                        arrowcolor=ARROW_COLOR, 
                        arrowsize=9,         
                        width=9,              
                        relief="flat")         
        
        style.configure("TCheckbutton", 
                        background=BG_MAIN, 
                        foreground=TEXT_COLOR, 
                        focuscolor=BG_MAIN)
        
        style.map("TCheckbutton",
                  background=[("active", BG_MAIN)], 
                  indicatorcolor=[("selected", ACCENT_BLUE), ("!selected", "#555555")],
                  foreground=[("active", "white")])
        
        # INTERACTION MAP (Hover effects)
        style.map("Vertical.TScrollbar",
                  background=[("pressed", TEAL_PRESS), ("active", TEAL_HOVER)],
                  arrowcolor=[("pressed", "white"), ("active", "white")])
        
        style.configure("TLabelframe", 
                        background="#2d2d30", 
                        bordercolor="#444444", 
                        borderwidth=1,
                        relief="flat",        
                        lightcolor="#2d2d30", 
                        darkcolor="#2d2d30")  
        
        style.configure("TLabelframe.Label", background="#2d2d30", foreground=TEXT_COLOR)

        style.configure("Treeview", 
                        background=BG_SURFACE, 
                        fieldbackground=BG_SURFACE, 
                        foreground=TEXT_COLOR, 
                        borderwidth=0, 
                        highlightthickness=0)
        
        style.layout("Treeview", [('Treeview.treearea', {'sticky': 'nswe'})])

        style.configure("Treeview.Heading", 
                        background="#333333", 
                        foreground=TEXT_COLOR, 
                        relief="flat",
                        borderwidth=1,
                        lightcolor="#333333", 
                        darkcolor="#333333")
                        
        style.map("Treeview.Heading",
                  background=[('active', '#454545'), ('pressed', ACCENT_BLUE)],
                  lightcolor=[('active', '#454545'), ('pressed', ACCENT_BLUE)],
                  darkcolor=[('active', '#454545'), ('pressed', ACCENT_BLUE)])
        
        # Global Frame & Label
        style.configure(".", background=BG_MAIN, foreground=TEXT_COLOR, font=("Segoe UI", 9))
        style.configure("TFrame", background=BG_MAIN)
        style.configure("TLabel", background=BG_MAIN, foreground=TEXT_COLOR)
        style.configure("TEntry", fieldbackground=BG_SURFACE, foreground=TEXT_COLOR, bordercolor="#333333", lightcolor="#333333")
        
        style.configure("TButton", padding=6, relief="flat", background="#46464a", foreground=TEXT_COLOR, borderwidth=0)
        style.map("TButton", 
                  background=[("active", "#5a5a5e"), ("pressed", ACCENT_BLUE)],
                  foreground=[("active", "white")])

        style.configure("Action.TButton", background=ACCENT_BLUE, foreground="white", font=("Segoe UI", 9, "bold"), padding=10, relief="flat", borderwidth=0)
        style.map("Action.TButton", background=[("active", "#0086f0"), ("pressed", "#0086f0")],
                  shift=[("pressed", (0, 0))])
        style.configure("Contrast.Horizontal.TProgressbar", troughcolor='#1e1e1e', background=ACCENT_BLUE, bordercolor='#2d2d30', thickness=10)
        
        style.configure("Visual.TButton", background="#355070", foreground="white", font=("Segoe UI", 9, "bold"))
        style.map("Visual.TButton", background=[('active', '#2d2536')])
        
        style.configure("Heat.TButton", background="#6d597a", foreground="white", font=("Segoe UI", 9, "bold"))
        style.map("Heat.TButton", background=[('active', '#373145')])

        # --- THE TOP NAVIGATION BAR ---
        nav_frame = tk.Frame(self, bg=BG_MAIN) 
        nav_frame.pack(side="top", fill="x")

        nav_settings = {
            "font": ("Segoe UI", 10, "bold"),
            "relief": "flat",
            "borderwidth": 0,
            "highlightthickness": 0,
            "activeforeground": "white",
            "pady": 9,
            "cursor": "hand2"
        }

        self.btn_nav_single = tk.Button(nav_frame, text="SINGLE MODE", 
                                        bg=BG_MAIN, fg=TEXT_COLOR, 
                                        activebackground=BG_SURFACE,
                                        command=lambda: self.show_page("single"),
                                        **nav_settings)
        self.btn_nav_single.pack(side="left", expand=True, fill="x")

        self.btn_nav_batch = tk.Button(nav_frame, text="BATCH MODE", 
                                       bg=BG_MAIN, fg=TEXT_COLOR, 
                                       activebackground=BG_SURFACE,
                                       command=lambda: self.show_page("batch"),
                                       **nav_settings)
        self.btn_nav_batch.pack(side="left", expand=True, fill="x")

        # --- THE PAGE CONTAINER ---
        self.container = ttk.Frame(self)
        self.container.pack(fill="both", expand=True)

        self.page_single = ttk.Frame(self.container)
        self.page_batch = ttk.Frame(self.container)

        for p in (self.page_single, self.page_batch):
            p.grid(row=0, column=0, sticky="nsew")
        
        self.container.rowconfigure(0, weight=1)
        self.container.columnconfigure(0, weight=1)

        self.setup_single_tab()
        self.setup_batch_tab()

        self.show_page("single")

        if not os.path.exists(SSIM_EXE) or not os.path.exists(BUTTER_EXE):
            messagebox.showwarning("Binaries Missing", f"Could not find executables.\n{BIN_DIR}")

    # ==========================================
    # COMMON
    # ==========================================
    def drop_handler(self, event, entry_widget):
        path = event.data
        if path.startswith('{') and path.endswith('}'): path = path[1:-1]
        entry_widget.delete(0, tk.END); entry_widget.insert(0, path)

    def open_info_window(self):
        info_win = tk.Toplevel(self)
        info_win.title("Metric Information")
        info_win.geometry("700x900")
        info_win.configure(bg="#46464a")
        apply_dark_theme(info_win)

        # 1. THE CONTAINER
        log_container = ttk.Frame(info_win)
        log_container.pack(fill="both", expand=True, padx=15, pady=15)

        # 2. THE SCROLLBAR
        sb = ttk.Scrollbar(log_container, orient="vertical")
        sb.pack(side="right", fill="y")

        # 3. THE TEXT BOX
        txt = tk.Text(log_container, wrap=tk.WORD, font=("Consolas", 10),
                      bg="#dce2e7", fg="#1a1a1a", borderwidth=0, 
                      yscrollcommand=sb.set, padx=15, pady=15)
        txt.pack(side="left", fill="both", expand=True)
        sb.config(command=txt.yview)
        
        txt.tag_config("h1", font=("Segoe UI", 14, "bold"), foreground="#2c3e50")
        txt.tag_config("h2", font=("Segoe UI", 11, "bold"), foreground="#e67e22")
        txt.tag_config("bold", font=("Segoe UI", 10, "bold"))
        txt.tag_config("green", foreground="green")
        txt.tag_config("red", foreground="red")
        txt.tag_config("magenta", foreground="magenta")

        # 1. SSIMULACRA 2
        txt.insert(tk.END, "SSIMULACRA 2\n\n", "h1")
        desc_ssim = (
            "SSIMULACRA2 is a visual fidelity metric based on the concept of the multi-scale structural "
            "similarity index measure (MS-SSIM), computed in a perceptually relevant color space, "
            "adding two other (asymmetric) error maps, and aggregating using two different norms. "
            "It is currently the most reputable visual quality metric according to its correlation "
            "with subjective results, and is considered a very robust means of comparing encoders. "
            "It is debatable whether Butteraugli is better for very high fidelity, but SSIMULACRA2 "
            "is considered the best for medium/low fidelity comparisons.\n\n"
        )
        txt.insert(tk.END, desc_ssim)
        txt.insert(tk.END, "Scoring Guide (Higher is Better | 0-100)\n", "h2")
        txt.insert(tk.END, "Results from average observer at 1:1 from a normal viewing distance.\n\n")
        txt.insert(tk.END, " 50  : Medium. Slightly annoying artifacts. (cjxl -d 5.0 / q45)\n", "red")
        txt.insert(tk.END, " 70  : High. Barely noticeable in a side-by-side comparison. Without reference to the original image, an average observer does not notice. (cjxl -d 2.5 / q73)\n")
        txt.insert(tk.END, " 80  : Very High. Not noticeable in a side-by-side comparison. (cjxl -d 1.5 / q85)\n")
        txt.insert(tk.END, " 85  : Excellent. Not noticeable in the condition of in-place comparison. (cjxl -d 1.0 / q90)\n")
        txt.insert(tk.END, " 90  : Vis. Lossless. Not noticeable in a flicker test. (cjxl -d 0.5 / q95)\n", "green")
        txt.insert(tk.END, " 100 : Math. Lossless.\n\n")
        txt.insert(tk.END, "-"*60 + "\n\n")

        # 2. BUTTERAUGLI
        txt.insert(tk.END, "BUTTERAUGLI\n\n", "h1")
        desc_butter = (
            "Butteraugli is a psychovisual image quality metric that estimates the perceived difference "
            "between two images. Unlike simple metrics like PSNR or MSE, butteraugli models human vision "
            "—color sensitivity, spatial masking, and contrast perception— to produce scores that correlate well"
            " with subjective quality assessments. It highlights differences "
            "that viewers actually see. The core tool outputs a single “distance” score along with "
            "per-pixel or per-region maps that show where artifacts are most objectionable.\n\n"
        )
        txt.insert(tk.END, desc_butter)
        txt.insert(tk.END, f"Scoring Guide (Lower is Better | Target: {INTENSITY} nits)\n", "h2")
        txt.insert(tk.END, " Score < 1.0  : Identical to most viewers\n", "green")
        txt.insert(tk.END, " 1.0 - 2.0    : Subtle differences may be noticeable\n")
        txt.insert(tk.END, " Score > 2.0  : Visible differences between images\n\n", "red")
        txt.insert(tk.END, "Look at the FIRST number (peak), the 3-norm is the average. If the peak is 1.5 "
                           "but the 3-Norm is 0.4, the image may be visually perfect almost everywhere, with isolated compression artifacts. "
                           "Heatmap will help to check that.\n\n")
        txt.insert(tk.END, "[ HEATMAP ] ", "magenta")
        txt.insert(tk.END, "Usually green spots are the threshold for vis. lossless territory.\n\n", "magenta")
        txt.insert(tk.END, "-"*60 + "\n\n")
        
        # 3. OVERALL COMPARISON
        txt.insert(tk.END, "OVERALL\n\n", "h1")
        txt.insert(tk.END, "SSIMULACRA 2\n", "h3")
        txt.insert(tk.END, "Uses a \"Structural Similarity\" approach. It cares about whether the structure of the image "
                           "(edges, textures) remains intact. It is tuned specifically to reward images that look like "
                           "the original, even if the pixel values are slightly different. It is currently considered the "
                           "gold standard for a visual quality metric.\n")
        txt.insert(tk.END, "BUTTERAUGLI\n", "h3")
        txt.insert(tk.END, "Is a \"Psychovisual Error\" metric. It calculates a \"distance\" or deviation. It cares "
                           "deeply about color artifacts and density. It is extremely sensitive to changes that might "
                           "be technically visible but not necessarily annoying.\n\n")
        txt.insert(tk.END, "The Butteraugli metric should be better at finding technical imperfections "
                           "while SSIMULACRA 2 scores correlate best with human eyes.", "bold")
        txt.config(state="disabled")

    # ==========================================
    # TAB 1: SINGLE
    # ==========================================
    def setup_single_tab(self):
        frame = ttk.Frame(self.page_single, padding=(10, 35, 10, 10))
        frame.pack(fill="both", expand=True)

        ttk.Label(frame, text="Original Image:").grid(row=0, column=0, sticky="w")
        self.ent_orig_s = ttk.Entry(frame, width=70)
        self.ent_orig_s.grid(row=0, column=1, padx=5, pady=5)
        if DND_SUPPORT:
            self.ent_orig_s.drop_target_register(DND_FILES)
            self.ent_orig_s.dnd_bind('<<Drop>>', lambda e: self.drop_handler(e, self.ent_orig_s))
        ttk.Button(frame, text="Browse", command=lambda: self.browse_file(self.ent_orig_s)).grid(row=0, column=2)

        ttk.Label(frame, text="Encoded Image:").grid(row=1, column=0, sticky="w")
        self.ent_dist_s = ttk.Entry(frame, width=70)
        self.ent_dist_s.grid(row=1, column=1, padx=5, pady=5)
        if DND_SUPPORT:
            self.ent_dist_s.drop_target_register(DND_FILES)
            self.ent_dist_s.dnd_bind('<<Drop>>', lambda e: self.drop_handler(e, self.ent_dist_s))
        ttk.Button(frame, text="Browse", command=lambda: self.browse_file(self.ent_dist_s)).grid(row=1, column=2)
        
        btn_frame = ttk.Frame(frame)
        btn_frame.grid(row=2, column=1, pady=(30, 20), sticky="ew")

        # Standard Buttons
        ttk.Button(btn_frame, text="Info 🛈", width=8, command=self.open_info_window).pack(side="left", padx=(0, 5))
        ttk.Button(btn_frame, text="RUN ANALYSIS", width=35, style="Action.TButton", command=self.start_single_thread).pack(side="left", padx=(0, 5))
        ttk.Button(btn_frame, text="OPTIMIZER (RD)", command=self.open_optimizer).pack(side="left", padx=(5, 5))

        ttk.Separator(btn_frame, orient="vertical").pack(side="left", fill="y", padx=10)

        # Advanced Buttons
        ttk.Button(btn_frame, text="DIFF. MAPS", style="Visual.TButton", command=self.open_visual_lab).pack(side="left", padx=(5, 5))

        self.btn_heatmap = ttk.Button(btn_frame, text="GENERATE HEATMAP", style="Heat.TButton", command=self.generate_and_open_heatmap, state="disabled")
        self.btn_heatmap.pack(side="right", fill="x", padx=(5, 0))

        log_container = ttk.Frame(frame)
        log_container.grid(row=3, column=0, columnspan=3, sticky="nsew", pady=(20, 10))
        self.log_single = tk.Text(log_container, height=30, font=("Consolas", 10),
                                  bg="#1e1e1e", fg="#cccccc", borderwidth=0, padx=10, pady=10)
                                  
        sb_s = ttk.Scrollbar(log_container, orient="vertical", command=self.log_single.yview)
        self.log_single.configure(yscrollcommand=sb_s.set)
        
        sb_s.pack(side="right", fill="y")
        self.log_single.pack(side="left", fill="both", expand=True)
        
        self.log_single.tag_config("cyan", foreground="cyan")
        self.log_single.tag_config("green", foreground="#00FF00")
        self.log_single.tag_config("yellow", foreground="yellow")
        self.log_single.tag_config("red", foreground="#FF4444")
        self.log_single.tag_config("darkgray", foreground="#666666") 
        self.log_single.tag_config("magenta", foreground="magenta")

        frame.rowconfigure(3, weight=1); frame.columnconfigure(1, weight=1)

    def open_optimizer(self): OptimizerWindow(self, SSIM_EXE)

    def open_visual_lab(self):
        if not PIL_SUPPORT or not MPL_SUPPORT:
            messagebox.showerror("Missing Libraries", 
                "This feature requires Pillow and Matplotlib.")
            return

        orig = self.ent_orig_s.get().strip().strip('"')
        dist = self.ent_dist_s.get().strip().strip('"')
        if not orig or not dist or not os.path.exists(orig) or not os.path.exists(dist):
            messagebox.showerror("Error", "Select files first.")
            return
        VisualLabWindow(self, orig, dist)
    
    def open_metrics_lab(self):
        if not MPL_SUPPORT:
            messagebox.showerror("Error", "Matplotlib required.")
            return
        BatchMetricsLabWindow(self)
        
    def open_plot_plus(self):
        if not MPL_SUPPORT:
            messagebox.showerror("Error", "Matplotlib required.")
            return
        PlotPlusWindow(self)    
    
    def start_single_thread(self):
        self.btn_heatmap.config(state="disabled")
        t = threading.Thread(target=self.run_single_analysis); t.daemon = True; t.start()

    def run_single_analysis(self):
        orig = self.ent_orig_s.get().strip().strip('"')
        dist = self.ent_dist_s.get().strip().strip('"')
        self.log_single.delete(1.0, tk.END)
        if not orig or not dist:
            self.log_single.insert(tk.END, "Error: Please select both images.\n", "red")
            return
        self.log(self.log_single, "=======================================================\n", "cyan")
        self.log(self.log_single, "                CALCULATING SCORES...\n")
        self.log(self.log_single, "=======================================================\n\n")

        # 1. Get Images
        orig_ready, orig_temp, orig_msg = get_ready_image(orig)
        dist_ready, dist_temp, dist_msg = get_ready_image(dist)

        # 2. Check Errors
        if orig_ready is None:
            self.log(self.log_single, f"Error (Original): {orig_msg}\n", "red")
            return
        if dist_ready is None:
            self.log(self.log_single, f"Error (Encoded): {dist_msg}\n", "red")
            cleanup_image(orig_ready, orig_temp)
            return

        # 3. Log Status explicitly
        if orig_temp: self.log(self.log_single, "Note: Original is being converted via Pillow.\n", "orange")
        else: self.log(self.log_single, "Info: Original using Native Decoder.\n", "darkgray")
        
        if dist_temp: self.log(self.log_single, "Note: Encoded is being converted via Pillow.\n", "orange")
        else: self.log(self.log_single, "Info: Encoded using Native Decoder.\n", "darkgray")
        
        self.log(self.log_single, "\n")

        try:
            self.log(self.log_single, "[ SSIMULACRA 2 ] (0-100)\n\n", "cyan")
            res_ssim = subprocess.run([SSIM_EXE, orig_ready, dist_ready], capture_output=True, text=True)
            output_ssim = res_ssim.stdout + res_ssim.stderr
            ssim_val = self.get_num(output_ssim)
            self.log(self.log_single, "RESULT: ")
            try:
                val_f = float(ssim_val)
                color = "green" if val_f >= 90 else "yellow" if val_f >= 70 else "red"
                self.log(self.log_single, f"{ssim_val}", color)
            except: self.log(self.log_single, f"{ssim_val}", "red")
            self.log(self.log_single, "\n\n\n")

            self.log(self.log_single, f"[ BUTTERAUGLI ] (Target: {INTENSITY} nits)\n\n", "cyan")
            
            cmd_butter = [BUTTER_EXE, orig_ready, dist_ready, "--intensity_target", INTENSITY]
            
            res_butter = subprocess.run(cmd_butter, capture_output=True, text=True)
            output_butter = res_butter.stdout + res_butter.stderr
            lines = output_butter.splitlines()
            
            if not lines: 
                self.log(self.log_single, "Error: No output from Butteraugli.\n", "red")
            else:
                max_raw = lines[0]
                butter_max = self.get_num(max_raw)
                butter_norm = "N/A"
                for line in lines:
                    if "3-norm" in line:
                        match = re.search(r"3-norm:\s*(\d+(\.\d+)?)", line)
                        if match: butter_norm = match.group(1)
                
                self.log(self.log_single, "RESULT:\n")
                self.log(self.log_single, "Peak (Distance): ")
                try:
                    b_val_f = float(butter_max)
                    color = "green" if b_val_f < 1.0 else "yellow" if b_val_f < 2.0 else "red"
                    self.log(self.log_single, f"{butter_max}", color)
                except: self.log(self.log_single, f"{butter_max}", "red")
                self.log(self.log_single, f"   3-Norm: {butter_norm}", "darkgray")
                self.log(self.log_single, "\n\n\n")

            self.btn_heatmap.config(state="normal")

        except Exception as e:
            self.log(self.log_single, f"\nCRITICAL ERROR: {str(e)}", "red")
        finally:
            cleanup_image(orig_ready, orig_temp)
            cleanup_image(dist_ready, dist_temp)

    def generate_and_open_heatmap(self):
        
        orig = self.ent_orig_s.get().strip().strip('"')
        dist = self.ent_dist_s.get().strip().strip('"')
        
        if not orig or not dist or not os.path.exists(orig) or not os.path.exists(dist):
            messagebox.showerror("Error", "Files not found.")
            return

        orig_ready, orig_temp, _ = get_ready_image(orig)
        dist_ready, dist_temp, _ = get_ready_image(dist)
        
        if not orig_ready or not dist_ready:
            messagebox.showerror("Error", "Could not load images for heatmap generation.")
            cleanup_image(orig_ready, orig_temp)
            cleanup_image(dist_ready, dist_temp)
            return

        try:
            heatmap_path = dist + "_heatmap.ppm"
            
            cmd = [BUTTER_EXE, orig_ready, dist_ready, "--intensity_target", INTENSITY, "--distmap", heatmap_path]
            subprocess.run(cmd, capture_output=True)
            
            if os.path.exists(heatmap_path):
                self.log(self.log_single, "[ BUTTERAUGLI HEATMAP ] ", "magenta")
                self.log(self.log_single, f"Saved to: {heatmap_path}\n", "darkgray")
                
                try: os.startfile(heatmap_path)
                except: subprocess.call(['open' if os.name == 'posix' else 'xdg-open', heatmap_path])
            else:
                messagebox.showerror("Error", "Heatmap file was not generated by the executable.")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to generate heatmap: {e}")
        finally:
            cleanup_image(orig_ready, orig_temp)
            cleanup_image(dist_ready, dist_temp)

    # ==========================================
    # TAB 2: BATCH
    # ==========================================
    def setup_batch_tab(self):
        frame = ttk.Frame(self.page_batch, padding=(10, 35, 10, 10))
        frame.pack(fill="both", expand=True)

        ttk.Label(frame, text="Original Folder:").grid(row=0, column=0, sticky="w")
        self.ent_orig_b = ttk.Entry(frame, width=70)
        self.ent_orig_b.grid(row=0, column=1, padx=5, pady=5)
        if DND_SUPPORT:
            self.ent_orig_b.drop_target_register(DND_FILES)
            self.ent_orig_b.dnd_bind('<<Drop>>', lambda e: self.drop_handler(e, self.ent_orig_b))
        ttk.Button(frame, text="Browse", command=lambda: self.browse_folder(self.ent_orig_b)).grid(row=0, column=2)

        ttk.Label(frame, text="Encoded Folder:").grid(row=1, column=0, sticky="w")
        self.ent_dist_b = ttk.Entry(frame, width=70)
        self.ent_dist_b.grid(row=1, column=1, padx=5, pady=5)
        if DND_SUPPORT:
            self.ent_dist_b.drop_target_register(DND_FILES)
            self.ent_dist_b.dnd_bind('<<Drop>>', lambda e: self.drop_handler(e, self.ent_dist_b))
        ttk.Button(frame, text="Browse", command=lambda: self.browse_folder(self.ent_dist_b)).grid(row=1, column=2)

        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(frame, variable=self.progress_var, maximum=100, style="Contrast.Horizontal.TProgressbar")
        self.progress_bar.grid(row=3, column=0, columnspan=3, sticky="ew", pady=15)
        
        # 1. The Lightning Button 
        self.btn_speed = ttk.Button(frame, text="⚡", width=3, command=self.open_thread_config)
        self.btn_speed.grid(row=4, column=0, sticky="w", padx=(0, 5))
        
        self.lbl_status = ttk.Label(frame, text="Ready")
        self.lbl_status.grid(row=4, column=0, columnspan=3)

        btn_row = ttk.Frame(frame)
        btn_row.grid(row=2, column=1, pady=(30, 20), sticky="ew")

        ttk.Button(btn_row, text="Info 🛈", width=8, command=self.open_info_window).pack(side="left", padx=(0, 5))
        self.btn_batch_run = ttk.Button(btn_row, text="RUN ANALYSIS", width=35, style="Action.TButton", command=self.start_batch_thread)
        self.btn_batch_run.pack(side="left",  padx=(0, 5))
        self.btn_plot = ttk.Button(btn_row, text="PLOT", width=8, command=self.plot_batch_results, state="disabled")
        self.btn_plot.pack(side="left", padx=(5, 0))
        
        ttk.Separator(btn_row, orient="vertical").pack(side="left", fill="y", padx=10)
        
        self.btn_csv = ttk.Button(btn_row, text="CSV", width=8, command=self.save_batch_csv, state="disabled")
        self.btn_csv.pack(side="left", padx=(5, 0))
        ttk.Button(btn_row, text="OPTIMIZER", width=12, command=self.open_metrics_lab).pack(side="left", padx=(5, 0))
        ttk.Button(btn_row, text="PLOT +", width=10, command=self.open_plot_plus).pack(side="left", padx=(5, 0))

        log_container_b = ttk.Frame(frame)
        log_container_b.grid(row=5, column=0, columnspan=3, sticky="nsew", pady=(10, 10))

        self.log_batch = tk.Text(log_container_b, height=20, font=("Consolas", 10),
                                 bg="#1e1e1e", fg="#cccccc", borderwidth=0, padx=10, pady=10)
        
        sb_b = ttk.Scrollbar(log_container_b, orient="vertical", command=self.log_batch.yview)
        self.log_batch.configure(yscrollcommand=sb_b.set)
        sb_b.pack(side="right", fill="y")
        self.log_batch.pack(side="left", fill="both", expand=True)
        
        self.log_batch.tag_config("cyan", foreground="cyan")
        self.log_batch.tag_config("green", foreground="#00FF00")
        self.log_batch.tag_config("yellow", foreground="yellow")
        self.log_batch.tag_config("red", foreground="red")
        self.log_batch.tag_config("gray", foreground="#888888")
        self.log_batch.tag_config("darkgray", foreground="#666666")

        frame.rowconfigure(5, weight=1); frame.columnconfigure(1, weight=1)

    def start_batch_thread(self):
        self.btn_batch_run.config(state="disabled")
        self.btn_csv.config(state="disabled")
        self.btn_plot.config(state="disabled")
        t = threading.Thread(target=self.run_batch_analysis); t.daemon = True; t.start()
        
    def get_ready_image_optimized(self, file_path):
        if not os.path.exists(file_path):
            return None, False, "Not Found", 0, 0

        ext = os.path.splitext(file_path)[1].lower()
        w, h = 0, 0

        # --- 1. NATIVE FORMATS (.png, .jpg, .jxl) ---
        if ext in CLI_NATIVE_EXTS:
            try:
                with Image.open(file_path) as img:
                    w, h = img.size
            except:
                pass 
            return file_path, False, "Native", w, h
        
        # --- 2. NON-NATIVE FORMATS (.bmp, .webp, .tif, etc.) ---
        if not PIL_SUPPORT:
            return None, False, "No Pillow", 0, 0
        
        try:
            with Image.open(file_path) as img:
                w, h = img.size
                rgb_img = img.convert("RGB")
                
                fname = os.path.basename(file_path)
                unique_id = str(uuid.uuid4())[:8] 
                temp_path = os.path.join(tempfile.gettempdir(), f"{fname}_{unique_id}.tmp.png")

                rgb_img.save(temp_path, format="PNG", compress_level=0)
                return temp_path, True, "Converted", w, h
        except Exception as e:
            return None, False, str(e), 0, 0

    def process_image_pair(self, data):
        orig_path, dist_folder, base_name = data
        
        my_env = os.environ.copy()
        my_env["OMP_NUM_THREADS"] = "1"
        
        target_path = None
        for ext in ALL_SUPPORTED_EXTS:
            candidate = os.path.join(dist_folder, base_name + ext)
            if os.path.exists(candidate):
                target_path = candidate; break
        
        if not target_path: return None

        o_ready, o_temp, _, o_w, o_h = self.get_ready_image_optimized(orig_path)
        t_ready, t_temp, _, _, _     = self.get_ready_image_optimized(target_path)
        
        was_converted = o_temp or t_temp

        if o_ready is None or t_ready is None:
            cleanup_image(o_ready, o_temp)
            return None
        
        s_val, b_val, norm3, bpp = -1.0, -1.0, -1.0, 0.0
        
        try:
            # 1. Calculate BPP
            if o_w > 0 and o_h > 0:
                file_size = os.stat(target_path).st_size 
                bpp = (file_size * 8) / (o_w * o_h)

            # 2. SSIMULACRA 2
            cmd_s = [SSIM_EXE, o_ready, t_ready]
            res_s = subprocess.run(cmd_s, env=my_env, capture_output=True, text=True)
            s_val = float(self.get_num(res_s.stdout + res_s.stderr)) if self.get_num(res_s.stdout + res_s.stderr) != "ERR" else -1.0

            # 3. BUTTERAUGLI
            cmd_b = [BUTTER_EXE, o_ready, t_ready, "--intensity_target", INTENSITY]
            res_b = subprocess.run(cmd_b, capture_output=True, text=True, env=my_env)
            
            b_out = res_b.stdout + res_b.stderr
            m_norm = re.search(r"3-norm:\s*(\d+(\.\d+)?)", b_out)
            if m_norm: norm3 = float(m_norm.group(1))
            
            clean_b_out = b_out.split("3-norm")[0] if "3-norm" in b_out else b_out
            m_max = re.search(r"(\d+(\.\d+)?)", clean_b_out)
            b_val = float(m_max.group(1)) if m_max else -1.0
            
        except Exception as e:
            print(f"Error processing {base_name}: {e}")

        cleanup_image(o_ready, o_temp); cleanup_image(t_ready, t_temp)
        
        return {"Name": base_name, "BPP": bpp, "SSIM": s_val, 
                "Butter": b_val, "Butter3N": norm3, "Converted": was_converted}

    def run_batch_analysis(self):
        orig_dir = self.ent_orig_b.get().strip().strip('"')
        dist_dir = self.ent_dist_b.get().strip().strip('"')
        self.log_batch.delete(1.0, tk.END)
        
        if not os.path.isdir(orig_dir) or not os.path.isdir(dist_dir):
            self.log_batch.insert(tk.END, "Error: Invalid directories selected.\n")
            self.btn_batch_run.config(state="normal")
            return
        
        self.log(self.log_batch, "Scanning folders recursively...\n", "yellow")
        self.update_idletasks()
        
        dist_manifest = set()
        for root, _, filenames in os.walk(dist_dir):
            for f in filenames:
                rel_p = os.path.relpath(os.path.join(root, f), dist_dir)
                dist_manifest.add(rel_p.lower())

        # --- RECURSIVE SCAN ---
        tasks = []
        non_native_count = 0
        
        for root, _, filenames in os.walk(orig_dir):
            for f in filenames:
                _, ext = os.path.splitext(f)
                orig_ext = ext.lower()

                if orig_ext in ALL_SUPPORTED_EXTS:
                    orig_full_path = os.path.join(root, f)
                    
                    rel_path = os.path.relpath(orig_full_path, orig_dir)
                    rel_base = os.path.splitext(rel_path)[0] 

                    for cand_ext in ALL_SUPPORTED_EXTS:
                        if (rel_base + cand_ext).lower() in dist_manifest:
                            tasks.append((orig_full_path, dist_dir, rel_base))

                            if orig_ext not in CLI_NATIVE_EXTS: non_native_count += 1
                            if cand_ext not in CLI_NATIVE_EXTS: non_native_count += 1
                            break 

        total = len(tasks)
        if total == 0:
            self.log_batch.insert(tk.END, "No supported image files found in Original folder tree.\n")
            self.btn_batch_run.config(state="normal")
            return

        self.log(self.log_batch, "=======================================================\n", "cyan")
        self.log(self.log_batch, "                CALCULATING SCORES...\n")
        self.log(self.log_batch, "=======================================================\n\n")
        
        if non_native_count > 0:
            self.log(self.log_batch, f"WARNING: {non_native_count} files require Pillow conversion.\n", "orange")
        else:
            self.log(self.log_batch, "All files use Native Decoder.\n\n", "darkgray")

        self.log(self.log_batch, f"Found {total} images (including subfolders). Starting...\n", "yellow") 
        
        self.last_results = []
        completed = 0
        
        # 3. THREADING STRATEGY
        user_limit = self.batch_thread_count.get()
        
        if user_limit > 0:
            cpu_cores = user_limit
            self.log(self.log_batch, f"Engine: Manual Limit ({cpu_cores} threads)\n", "darkgray")
        else:
            cpu_cores = os.cpu_count() or 4
            self.log(self.log_batch, f"Engine: Ultimate Speed ({cpu_cores} threads)\n", "darkgray")
         
        with ThreadPoolExecutor(max_workers=cpu_cores) as executor:
            futures = [executor.submit(self.process_image_pair, task) for task in tasks]
            
            for future in futures:
                res = future.result()
                if res: 
                    self.last_results.append(res)
                completed += 1
                if completed % 5 == 0 or completed == total:
                    pct = (completed / total) * 100
                    self.after(0, lambda: self.progress_var.set(pct))
                    self.after(0, lambda: self.lbl_status.config(text=f"Analyzed {completed}/{total} ({pct:.1f}%)"))
                    self.update_idletasks()

        self.lbl_status.config(text="Analysis Complete.")
        self.last_results.sort(key=lambda x: x["Name"])

        if self.last_results:
            self.log(self.log_batch, "==========================================\n", "yellow")
            self.log(self.log_batch, "           ANALYSIS COMPLETE              \n")
            self.log(self.log_batch, "==========================================\n\n")
            self.show_stats("SSIMULACRA 2 (Higher is Better)", [r["SSIM"] for r in self.last_results], False)
            self.show_stats("BUTTERAUGLI (Lower is Better)", [r["Butter"] for r in self.last_results], True, [r["Butter3N"] for r in self.last_results])
            self.btn_csv.config(state="normal")
            if MPL_SUPPORT: 
                self.btn_plot.config(state="normal")
        self.btn_batch_run.config(state="normal")

    def save_batch_csv(self):
        if not self.last_results:
            messagebox.showinfo("Info", "No results to save.")
            return

        dist_dir = self.ent_dist_b.get().strip().strip('"')
        folder_name = os.path.basename(dist_dir)
        if not folder_name: folder_name = "batch_results"
        
        csv_path = os.path.join(dist_dir, f"!{folder_name}_metrics.csv")
        
        try:
            with open(csv_path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(["Filename", "BPP", "SSIM2", "Butter_Peak", "Butter_3Norm"])
                
                for r in self.last_results:
                    bpp_val = r.get("BPP", 0.0)
                    
                    writer.writerow([
                        r["Name"], 
                        f"{bpp_val:.6f}", 
                        f"{r['SSIM']:.4f}", 
                        f"{r['Butter']:.4f}", 
                        f"{r['Butter3N']:.4f}"
                    ])
                    
            messagebox.showinfo("Success", f"Unified Metrics CSV saved:\n{csv_path}")
        except Exception as e: 
            messagebox.showerror("Error", f"Could not save CSV: {str(e)}")

    def plot_batch_results(self):
        if not MPL_SUPPORT:
            messagebox.showwarning("Missing Library", "Matplotlib not found.")
            return
        
        plt.close('all') 
        
        names = [r["Name"] for r in self.last_results]
        ssim = [r["SSIM"] for r in self.last_results]
        b_max = [r["Butter"] for r in self.last_results]
        b_3n = [r["Butter3N"] for r in self.last_results]

        from matplotlib.figure import Figure
        fig = Figure(figsize=(15, 4.5))
        ax1, ax2 = fig.add_subplot(211), fig.add_subplot(212)

        # --- THE GAPPED TITLE ---
        fig.suptitle("Batch Analysis Results (Strip Heatmap)", fontsize=14, fontweight='bold', y=0.97)

        fig.subplots_adjust(hspace=0.4, right=0.98, left=0.1, bottom=0.12, top=0.82)

        # Plot SSIM
        ssim_data = np.array([ssim])
        im1 = ax1.imshow(ssim_data, cmap='Spectral', aspect='auto', vmin=50, vmax=100)
        ax1.set_yticks([0]); ax1.set_yticklabels(["SSIM 2"], fontweight='bold'); ax1.set_xticks([])
        fig.colorbar(im1, ax=ax1, fraction=0.046, pad=0.04).set_label('Quality')

        # Plot Butter
        butter_data = np.array([b_max, b_3n])
        im2 = ax2.imshow(butter_data, cmap='Spectral_r', aspect='auto', vmin=0, vmax=3.0)
        ax2.set_yticks([0, 1]); ax2.set_yticklabels(["Butter Peak", "Butter 3N"], fontweight='bold'); ax2.set_xticks([])
        fig.colorbar(im2, ax=ax2, fraction=0.046, pad=0.04).set_label('Distance')

        ax1.format_coord = lambda x, y: ""
        ax2.format_coord = lambda x, y: ""

        # Strip Hover Logic
        def hover(event):
            if event.inaxes in [ax1, ax2]:
                try:
                    col = int(round(event.xdata))
                    if 0 <= col < len(names):
                        n = names[col]
                        s = ssim[col]
                        bm = b_max[col]
                        b3 = b_3n[col]
                        msg = f"File: {n}  |  SSIM: {s:.2f}  |  Butter Peak: {bm:.2f}  |  Butter 3N: {b3:.2f}"
                        fig.canvas.toolbar.set_message(msg)
                except: fig.canvas.toolbar.set_message("")
            
        canvas = self.show_plot_window(fig, "Batch Analysis Results")
        canvas.mpl_connect("motion_notify_event", hover)
    
    def show_stats(self, title, data_list, is_butter, sec_list=None):
        valid = [x for x in data_list if x >= 0]
        if not valid:
            self.log(self.log_batch, f" {title} - No valid data.\n", "red")
            return
        valid.sort()
        avg, median, d_min, d_max = statistics.mean(valid), statistics.median(valid), valid[0], valid[-1]
        idx = int(len(valid) * (0.95 if is_butter else 0.05))
        p_val = valid[min(idx, len(valid)-1)]
        p_label = "95th % (Worst)" if is_butter else "5th %  (Worst)"
        color = "cyan" if is_butter else "green"

        self.log(self.log_batch, "-"*32 + "\n", "gray")
        self.log(self.log_batch, f" {title}\n", color)
        self.log(self.log_batch, "-"*32 + "\n", "gray")
        self.log(self.log_batch, f" Average:  {avg:.4f}")
        if sec_list:
            v2 = [x for x in sec_list if x >= 0]
            if v2: self.log(self.log_batch, f" (3-Norm Avg: {statistics.mean(v2):.4f})", "darkgray")
        self.log(self.log_batch, f"\n Median:   {median:.4f}\n Min:      {d_min:.4f}\n Max:      {d_max:.4f}\n {p_label}: {p_val:.4f}\n\n")

    def browse_file(self, entry):
        f = filedialog.askopenfilename(filetypes=[("All Images", ALL_SUPPORTED_EXTS)])
        if f: entry.delete(0, tk.END); entry.insert(0, f)
    def browse_folder(self, entry):
        d = filedialog.askdirectory()
        if d: entry.delete(0, tk.END); entry.insert(0, d)
    def log(self, widget, text, tag=None):
        self.after(0, lambda: self._log_safe(widget, text, tag))

    def _log_safe(self, widget, text, tag):
        widget.insert(tk.END, text, tag)
        widget.see(tk.END)
    def get_num(self, text):
        m = re.search(r"(\d+(\.\d+)?)", text)
        return m.group(0) if m else "ERR"
    
    def open_thread_config(self):
        win = tk.Toplevel(self)
        win.title("Threads")
        win.geometry("220x170")
        win.configure(bg="#2d2d30") 
        apply_dark_theme(win)
        
        ttk.Label(win, text="Max CPU Threads:", font=("Segoe UI", 10, "bold")).pack(pady=(20, 5))
        ttk.Label(win, text="(0 = Auto / Ultimate)", font=("Segoe UI", 8)).pack(pady=(0, 10))
        
        spin = tk.Spinbox(
            win, 
            from_=0, 
            to=256, 
            width=5, 
            textvariable=self.batch_thread_count, 
            font=("Consolas", 12, "bold"),
            bg="#dce2e7",       
            fg="#000000",     
            buttonbackground="#dce2e7",
            relief="flat"      
        )

        spin.pack(pady=5, ipady=4)
        
        ttk.Button(win, text="OK", command=win.destroy).pack(pady=15)
    
    def show_page(self, page_id):
        ACCENT_BLUE = "#0078d4" 
        BG_INACTIVE = "#2d2d30" 
        TEXT_COLOR = "#e1e1e1"

        if page_id == "single":
            self.page_single.tkraise()
            self.btn_nav_single.config(bg=ACCENT_BLUE, fg="white")
            self.btn_nav_batch.config(bg=BG_INACTIVE, fg=TEXT_COLOR)
        else:
            self.page_batch.tkraise()
            self.btn_nav_batch.config(bg=ACCENT_BLUE, fg="white")
            self.btn_nav_single.config(bg=BG_INACTIVE, fg=TEXT_COLOR)
            
    def show_plot_window(self, fig, title):
        win = tk.Toplevel(self)
        win.title(title)
        main_icon = getattr(self, 'app_icon', None) or getattr(self.master, 'app_icon', None)
        if main_icon:
            win.iconphoto(True, main_icon)
        canvas = FigureCanvasTkAgg(fig, master=win)
        canvas.get_tk_widget().pack(fill="both", expand=True)
        toolbar = NavigationToolbar2Tk(canvas, win)
        toolbar.update()
        canvas.draw()
        return canvas
    
if __name__ == "__main__":

    if os.name == 'nt':
        myappid = 'IMGMETRICTOOL.v2'
        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
        try:
            kernel32 = ctypes.windll.kernel32
            kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)
        except:
            pass 

    # --- 2. DEFINE COLORS ---
    class Col:
        CYAN  = '\033[96m'
        GREEN = '\033[92m'
        YELLOW= '\033[93m'
        RED   = '\033[91m'
        GRAY  = '\033[90m'
        RESET = '\033[0m'
        BOLD  = '\033[1m'

    # --- 3. CONSOLE STARTUP REPORT ---
    print("\n" + Col.CYAN + "="*50)
    print(f"      {Col.BOLD}DEPENDENCY CHECK{Col.RESET}{Col.CYAN}")
    print("="*50 + Col.RESET + "\n")
    
    checks = [
        ("TkinterDnD",   DND_SUPPORT),
        ("Pillow",       PIL_SUPPORT),
        ("Matplotlib",   MPL_SUPPORT),
        ("OpenCV",       CV_SUPPORT),
        ("Scikit-Image", SKIMAGE_SUPPORT),
        ("SciPy",        SCIPY_SUPPORT),
    ]

    print(f"  {Col.GRAY}Library              Status{Col.RESET}")
    print(f"  {Col.GRAY}-------              ------{Col.RESET}")

    for name, status in checks:
        n_col = Col.BOLD if status else Col.GRAY
        s_txt = f"{Col.GREEN}[OK]{Col.RESET}" if status else f"{Col.RED}[MISSING]{Col.RESET}"
        
        print(f"  {n_col}{name.ljust(20)}{Col.RESET} {s_txt}")
        
    print()
    print(Col.CYAN + "-" * 50 + Col.RESET)
    print()
    # --- 4. BINARY CHECK ---
    
    ssim_ok = os.path.exists(SSIM_EXE)
    butter_ok = os.path.exists(BUTTER_EXE)
    
    s_label = "SSIMULACRA 2".ljust(20)
    s_status = f"{Col.GREEN}[OK]{Col.RESET}" if ssim_ok else f"{Col.RED}[MISSING]{Col.RESET}"
    print(f"  {Col.BOLD}{s_label}{Col.RESET} {s_status}")

    b_label = "BUTTERAUGLI".ljust(20)
    b_status = f"{Col.GREEN}[OK]{Col.RESET}" if butter_ok else f"{Col.RED}[MISSING]{Col.RESET}"
    print(f"  {Col.BOLD}{b_label}{Col.RESET} {b_status}")
    
    # --- 5. LAUNCH APP ---
    app = MetricToolGUI()
    app.mainloop()
